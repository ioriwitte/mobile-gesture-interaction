'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// http://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser
var isNode = new Function('try { return this === global; } catch(e) { return false }');

/**
 * Create a function that returns time in milliseconds according to the current
 * environnement (node or browser).
 * If running in node the time rely on `process.hrtime`, while if in the browser
 * it is provided by the `currentTime` of an `AudioContext`, this context can
 * optionnaly be provided to keep time consistency between several `EventIn`
 * nodes.
 *
 * @param {AudioContext} [audioContext=null] - Optionnal audio context.
 * @return {Function}
 * @private
 */
function getTimeFunction() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (isNode()) {
    return function () {
      var t = process.hrtime();
      return (t[0] + t[1] * 1e-9) * 1e3;
    };
  } else {
    return function () {
      return performance.now();
    };
  }
}

/**
 * @callback TickerCallback
 * @param {Number} logicalTime - logical time since `start` in ms
 * @param {Number} currentTime - current time as returned by `performance.now`
 * @param {Number} error - current error
 */

/**
 * Precise periodic timer (based on `setTimeout`) that monitor and adapt itself
 * to stay close to the given therical period. In particular, try to minimize
 * the drift caused by the use of a raw `setTimeout`.
 * Observed average jitter is around +/- 2ms.
 *
 * @param {Number} period - period of the timer interval in milliseconds
 *  (floored if float is given)
 * @param {TickerCallback} callback - callback to execute on each tick
 * @param {Object} options - additionnal options
 * @param {Number} [options.errorThreshold] - Threshold error where the timer
 *  considers itself as out of bounds. Increasing this value tends to increase
 *  the overall jitter.
 */

var Ticker = function () {
  function Ticker(period, callback) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$errorThreshold = _ref.errorThreshold,
        errorThreshold = _ref$errorThreshold === undefined ? 0.4 : _ref$errorThreshold;

    _classCallCheck(this, Ticker);

    period = Math.floor(period);

    this.logicalPeriod = period;
    this.computedPeriod = period;
    this.callback = callback;
    this.errorThreshold = errorThreshold;
    this.isRunning = false;
    this.getTime = getTimeFunction();

    this._tick = this._tick.bind(this);
  }

  /**
   * Period of the timer. Must be an integer, the given value is floored.
   * When updated the new value is applied at the next tick.
   *
   * @name period
   * @type {Number}
   * @instance
   * @memberof Ticker
   */


  _createClass(Ticker, [{
    key: 'start',


    /**
     * Start the ticker instance.
     */
    value: function start() {
      if (!this.isRunning) {
        this.startTime = this.getTime();
        this.logicalTime = 0;

        this._tick(); // run now

        this.isRunning = true;
      }
    }

    /**
     * Stop the ticker instance.
     */

  }, {
    key: 'stop',
    value: function stop() {
      clearTimeout(this.timeoutId);
      this.isRunning = false;
    }

    /** @private */

  }, {
    key: '_tick',
    value: function _tick() {
      var now = this.getTime();
      var time = now - this.startTime;
      var error = time - this.logicalTime;

      if (error >= this.errorThreshold) this.computedPeriod = this.computedPeriod - 1;

      if (error < -this.errorThreshold) this.computedPeriod = this.logicalPeriod;

      this.timeoutId = setTimeout(this._tick, this.computedPeriod);

      this.callback(this.logicalTime, now, error);
      // next call time
      this.logicalTime += this.logicalPeriod;
    }
  }, {
    key: 'period',
    set: function set(value) {
      value = Math.floor(value);
      this.logicalPeriod = value;
      this.computedPeriod = value;
    },
    get: function get() {
      return this.logicalPeriod;
    }
  }]);

  return Ticker;
}();

exports.default = Ticker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlRpY2tlci5qcyJdLCJuYW1lcyI6WyJpc05vZGUiLCJGdW5jdGlvbiIsImdldFRpbWVGdW5jdGlvbiIsImF1ZGlvQ29udGV4dCIsInQiLCJwcm9jZXNzIiwiaHJ0aW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJUaWNrZXIiLCJwZXJpb2QiLCJjYWxsYmFjayIsImVycm9yVGhyZXNob2xkIiwiTWF0aCIsImZsb29yIiwibG9naWNhbFBlcmlvZCIsImNvbXB1dGVkUGVyaW9kIiwiaXNSdW5uaW5nIiwiZ2V0VGltZSIsIl90aWNrIiwiYmluZCIsInN0YXJ0VGltZSIsImxvZ2ljYWxUaW1lIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dElkIiwidGltZSIsImVycm9yIiwic2V0VGltZW91dCIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFNQSxTQUFTLElBQUlDLFFBQUosQ0FBYSwyREFBYixDQUFmOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFTQyxlQUFULEdBQThDO0FBQUEsTUFBckJDLFlBQXFCLHVFQUFOLElBQU07O0FBQzVDLE1BQUlILFFBQUosRUFBYztBQUNaLFdBQU8sWUFBTTtBQUNYLFVBQU1JLElBQUlDLFFBQVFDLE1BQVIsRUFBVjtBQUNBLGFBQU8sQ0FBQ0YsRUFBRSxDQUFGLElBQU9BLEVBQUUsQ0FBRixJQUFPLElBQWYsSUFBdUIsR0FBOUI7QUFDRCxLQUhEO0FBSUQsR0FMRCxNQUtPO0FBQ0wsV0FBTztBQUFBLGFBQU1HLFlBQVlDLEdBQVosRUFBTjtBQUFBLEtBQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7OztJQWNNQyxNO0FBQ0osa0JBQVlDLE1BQVosRUFBb0JDLFFBQXBCLEVBQTZEO0FBQUEsbUZBQUosRUFBSTtBQUFBLG1DQUE3QkMsY0FBNkI7QUFBQSxRQUE3QkEsY0FBNkIsdUNBQVosR0FBWTs7QUFBQTs7QUFDM0RGLGFBQVNHLEtBQUtDLEtBQUwsQ0FBV0osTUFBWCxDQUFUOztBQUVBLFNBQUtLLGFBQUwsR0FBcUJMLE1BQXJCO0FBQ0EsU0FBS00sY0FBTCxHQUFzQk4sTUFBdEI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsU0FBS0ssU0FBTCxHQUFpQixLQUFqQjtBQUNBLFNBQUtDLE9BQUwsR0FBZWhCLGlCQUFmOztBQUVBLFNBQUtpQixLQUFMLEdBQWEsS0FBS0EsS0FBTCxDQUFXQyxJQUFYLENBQWdCLElBQWhCLENBQWI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7NEJBR1E7QUFDTixVQUFJLENBQUMsS0FBS0gsU0FBVixFQUFxQjtBQUNuQixhQUFLSSxTQUFMLEdBQWlCLEtBQUtILE9BQUwsRUFBakI7QUFDQSxhQUFLSSxXQUFMLEdBQW1CLENBQW5COztBQUVBLGFBQUtILEtBQUwsR0FKbUIsQ0FJTDs7QUFFZCxhQUFLRixTQUFMLEdBQWlCLElBQWpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OzJCQUdPO0FBQ0xNLG1CQUFhLEtBQUtDLFNBQWxCO0FBQ0EsV0FBS1AsU0FBTCxHQUFpQixLQUFqQjtBQUNEOztBQUVEOzs7OzRCQUNRO0FBQ04sVUFBTVQsTUFBTSxLQUFLVSxPQUFMLEVBQVo7QUFDQSxVQUFNTyxPQUFPakIsTUFBTSxLQUFLYSxTQUF4QjtBQUNBLFVBQU1LLFFBQVFELE9BQU8sS0FBS0gsV0FBMUI7O0FBRUEsVUFBSUksU0FBUyxLQUFLZCxjQUFsQixFQUNFLEtBQUtJLGNBQUwsR0FBc0IsS0FBS0EsY0FBTCxHQUFzQixDQUE1Qzs7QUFFRixVQUFJVSxRQUFRLENBQUMsS0FBS2QsY0FBbEIsRUFDRSxLQUFLSSxjQUFMLEdBQXNCLEtBQUtELGFBQTNCOztBQUVGLFdBQUtTLFNBQUwsR0FBaUJHLFdBQVcsS0FBS1IsS0FBaEIsRUFBdUIsS0FBS0gsY0FBNUIsQ0FBakI7O0FBRUEsV0FBS0wsUUFBTCxDQUFjLEtBQUtXLFdBQW5CLEVBQWdDZCxHQUFoQyxFQUFxQ2tCLEtBQXJDO0FBQ0E7QUFDQSxXQUFLSixXQUFMLElBQW9CLEtBQUtQLGFBQXpCO0FBQ0Q7OztzQkFqRFVhLEssRUFBTztBQUNoQkEsY0FBUWYsS0FBS0MsS0FBTCxDQUFXYyxLQUFYLENBQVI7QUFDQSxXQUFLYixhQUFMLEdBQXFCYSxLQUFyQjtBQUNBLFdBQUtaLGNBQUwsR0FBc0JZLEtBQXRCO0FBQ0QsSzt3QkFFWTtBQUNYLGFBQU8sS0FBS2IsYUFBWjtBQUNEOzs7Ozs7a0JBNENZTixNIiwiZmlsZSI6IlRpY2tlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc1NzU3OTAvZW52aXJvbm1lbnQtZGV0ZWN0aW9uLW5vZGUtanMtb3ItYnJvd3NlclxuY29uc3QgaXNOb2RlID0gbmV3IEZ1bmN0aW9uKCd0cnkgeyByZXR1cm4gdGhpcyA9PT0gZ2xvYmFsOyB9IGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH0nKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGltZSBpbiBtaWxsaXNlY29uZHMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gKiBlbnZpcm9ubmVtZW50IChub2RlIG9yIGJyb3dzZXIpLlxuICogSWYgcnVubmluZyBpbiBub2RlIHRoZSB0aW1lIHJlbHkgb24gYHByb2Nlc3MuaHJ0aW1lYCwgd2hpbGUgaWYgaW4gdGhlIGJyb3dzZXJcbiAqIGl0IGlzIHByb3ZpZGVkIGJ5IHRoZSBgY3VycmVudFRpbWVgIG9mIGFuIGBBdWRpb0NvbnRleHRgLCB0aGlzIGNvbnRleHQgY2FuXG4gKiBvcHRpb25uYWx5IGJlIHByb3ZpZGVkIHRvIGtlZXAgdGltZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIHNldmVyYWwgYEV2ZW50SW5gXG4gKiBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gW2F1ZGlvQ29udGV4dD1udWxsXSAtIE9wdGlvbm5hbCBhdWRpbyBjb250ZXh0LlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUaW1lRnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gbnVsbCkge1xuICBpZiAoaXNOb2RlKCkpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gKHRbMF0gKyB0WzFdICogMWUtOSkgKiAxZTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBUaWNrZXJDYWxsYmFja1xuICogQHBhcmFtIHtOdW1iZXJ9IGxvZ2ljYWxUaW1lIC0gbG9naWNhbCB0aW1lIHNpbmNlIGBzdGFydGAgaW4gbXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZSAtIGN1cnJlbnQgdGltZSBhcyByZXR1cm5lZCBieSBgcGVyZm9ybWFuY2Uubm93YFxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yIC0gY3VycmVudCBlcnJvclxuICovXG5cbi8qKlxuICogUHJlY2lzZSBwZXJpb2RpYyB0aW1lciAoYmFzZWQgb24gYHNldFRpbWVvdXRgKSB0aGF0IG1vbml0b3IgYW5kIGFkYXB0IGl0c2VsZlxuICogdG8gc3RheSBjbG9zZSB0byB0aGUgZ2l2ZW4gdGhlcmljYWwgcGVyaW9kLiBJbiBwYXJ0aWN1bGFyLCB0cnkgdG8gbWluaW1pemVcbiAqIHRoZSBkcmlmdCBjYXVzZWQgYnkgdGhlIHVzZSBvZiBhIHJhdyBgc2V0VGltZW91dGAuXG4gKiBPYnNlcnZlZCBhdmVyYWdlIGppdHRlciBpcyBhcm91bmQgKy8tIDJtcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIC0gcGVyaW9kIG9mIHRoZSB0aW1lciBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAqICAoZmxvb3JlZCBpZiBmbG9hdCBpcyBnaXZlbilcbiAqIEBwYXJhbSB7VGlja2VyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gY2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBlYWNoIHRpY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVycm9yVGhyZXNob2xkXSAtIFRocmVzaG9sZCBlcnJvciB3aGVyZSB0aGUgdGltZXJcbiAqICBjb25zaWRlcnMgaXRzZWxmIGFzIG91dCBvZiBib3VuZHMuIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSB0ZW5kcyB0byBpbmNyZWFzZVxuICogIHRoZSBvdmVyYWxsIGppdHRlci5cbiAqL1xuY2xhc3MgVGlja2VyIHtcbiAgY29uc3RydWN0b3IocGVyaW9kLCBjYWxsYmFjaywgeyBlcnJvclRocmVzaG9sZCA9IDAuNCB9ID0ge30pIHtcbiAgICBwZXJpb2QgPSBNYXRoLmZsb29yKHBlcmlvZCk7XG5cbiAgICB0aGlzLmxvZ2ljYWxQZXJpb2QgPSBwZXJpb2Q7XG4gICAgdGhpcy5jb21wdXRlZFBlcmlvZCA9IHBlcmlvZDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lcnJvclRocmVzaG9sZCA9IGVycm9yVGhyZXNob2xkO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5nZXRUaW1lID0gZ2V0VGltZUZ1bmN0aW9uKCk7XG5cbiAgICB0aGlzLl90aWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmlvZCBvZiB0aGUgdGltZXIuIE11c3QgYmUgYW4gaW50ZWdlciwgdGhlIGdpdmVuIHZhbHVlIGlzIGZsb29yZWQuXG4gICAqIFdoZW4gdXBkYXRlZCB0aGUgbmV3IHZhbHVlIGlzIGFwcGxpZWQgYXQgdGhlIG5leHQgdGljay5cbiAgICpcbiAgICogQG5hbWUgcGVyaW9kXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgVGlja2VyXG4gICAqL1xuICBzZXQgcGVyaW9kKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzLmxvZ2ljYWxQZXJpb2QgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbXB1dGVkUGVyaW9kID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2ljYWxQZXJpb2Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRpY2tlciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmxvZ2ljYWxUaW1lID0gMDtcblxuICAgICAgdGhpcy5fdGljaygpOyAvLyBydW4gbm93XG5cbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgdGlja2VyIGluc3RhbmNlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3RpY2soKSB7XG4gICAgY29uc3Qgbm93ID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZSA9IG5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIGNvbnN0IGVycm9yID0gdGltZSAtIHRoaXMubG9naWNhbFRpbWU7XG5cbiAgICBpZiAoZXJyb3IgPj0gdGhpcy5lcnJvclRocmVzaG9sZClcbiAgICAgIHRoaXMuY29tcHV0ZWRQZXJpb2QgPSB0aGlzLmNvbXB1dGVkUGVyaW9kIC0gMTtcblxuICAgIGlmIChlcnJvciA8IC10aGlzLmVycm9yVGhyZXNob2xkKVxuICAgICAgdGhpcy5jb21wdXRlZFBlcmlvZCA9IHRoaXMubG9naWNhbFBlcmlvZDtcblxuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90aWNrLCB0aGlzLmNvbXB1dGVkUGVyaW9kKTtcblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5sb2dpY2FsVGltZSwgbm93LCBlcnJvcik7XG4gICAgLy8gbmV4dCBjYWxsIHRpbWVcbiAgICB0aGlzLmxvZ2ljYWxUaW1lICs9IHRoaXMubG9naWNhbFBlcmlvZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWNrZXI7XG4iXX0=