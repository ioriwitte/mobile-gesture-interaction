'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var commonDefinitions = {
  min: {
    type: 'float',
    default: -1,
    metas: { kind: 'dynamic' }
  },
  max: {
    type: 'float',
    default: 1,
    metas: { kind: 'dynamic' }
  },
  width: {
    type: 'integer',
    default: 300,
    metas: { kind: 'dynamic' }
  },
  height: {
    type: 'integer',
    default: 150,
    metas: { kind: 'dynamic' }
  },
  container: {
    type: 'any',
    default: null,
    constant: true
  },
  canvas: {
    type: 'any',
    default: null,
    constant: true
  }
};

var hasDurationDefinitions = {
  duration: {
    type: 'float',
    min: 0,
    max: +Infinity,
    default: 1,
    metas: { kind: 'dynamic' }
  },
  referenceTime: {
    type: 'float',
    default: 0,
    constant: true
  }
};

/**
 * Base class to extend in order to create graphic sinks.
 *
 * <span class="warning">_This class should be considered abstract and only
 * be used to be extended._</span>
 *
 * @todo - fix float rounding errors (produce decays in sync draws)
 *
 * @memberof module:client.sink
 *
 * @param {Object} options - Override default parameters.
 * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
 *  _dynamic parameter_
 * @param {Number} [options.max=1] - Maximum value represented in the canvas.
 *  _dynamic parameter_
 * @param {Number} [options.width=300] - Width of the canvas.
 *  _dynamic parameter_
 * @param {Number} [options.height=150] - Height of the canvas.
 *  _dynamic parameter_
 * @param {Element|CSSSelector} [options.container=null] - Container element
 *  in which to insert the canvas. _constant parameter_
 * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
 *  in which to draw. _constant parameter_
 * @param {Number} [options.duration=1] - Duration (in seconds) represented in
 *  the canvas. This parameter only exists for operators that display several
 *  consecutive frames on the canvas. _dynamic parameter_
 * @param {Number} [options.referenceTime=null] - Optionnal reference time the
 *  display should considerer as the origin. Is only usefull when synchronizing
 *  several display using the `DisplaySync` class. This parameter only exists
 *  for operators that display several consecutive frames on the canvas.
 */

var BaseDisplay = function (_BaseLfo) {
  (0, _inherits3.default)(BaseDisplay, _BaseLfo);

  function BaseDisplay(defs) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var hasDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    (0, _classCallCheck3.default)(this, BaseDisplay);

    var commonDefs = void 0;

    if (hasDuration) commonDefs = (0, _assign2.default)({}, commonDefinitions, hasDurationDefinitions);else commonDefs = commonDefinitions;

    var definitions = (0, _assign2.default)({}, commonDefs, defs);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BaseDisplay.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay)).call(this, definitions, options));

    if (_this.params.get('canvas') === null && _this.params.get('container') === null) throw new Error('Invalid parameter: `canvas` or `container` not defined');

    var canvasParam = _this.params.get('canvas');
    var containerParam = _this.params.get('container');

    // prepare canvas
    if (canvasParam) {
      if (typeof canvasParam === 'string') _this.canvas = document.querySelector(canvasParam);else _this.canvas = canvasParam;
    } else if (containerParam) {
      var container = void 0;

      if (typeof containerParam === 'string') container = document.querySelector(containerParam);else container = containerParam;

      _this.canvas = document.createElement('canvas');
      container.appendChild(_this.canvas);
    }

    _this.ctx = _this.canvas.getContext('2d');
    _this.cachedCanvas = document.createElement('canvas');
    _this.cachedCtx = _this.cachedCanvas.getContext('2d');

    _this.hasDuration = hasDuration;
    _this.previousFrame = null;
    _this.currentTime = hasDuration ? _this.params.get('referenceTime') : null;

    /**
     * Instance of the `DisplaySync` used to synchronize the different displays
     * @private
     */
    _this.displaySync = false;

    _this._stack = [];
    _this._rafId = null;

    _this.renderStack = _this.renderStack.bind(_this);
    _this.shiftError = 0;

    // initialize canvas size and y scale transfert function
    _this._resize();
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(BaseDisplay, [{
    key: '_resize',
    value: function _resize() {
      var width = this.params.get('width');
      var height = this.params.get('height');

      var ctx = this.ctx;
      var cachedCtx = this.cachedCtx;

      var dPR = window.devicePixelRatio || 1;
      var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

      this.pixelRatio = dPR / bPR;

      var lastWidth = this.canvasWidth;
      var lastHeight = this.canvasHeight;
      this.canvasWidth = width * this.pixelRatio;
      this.canvasHeight = height * this.pixelRatio;

      cachedCtx.canvas.width = this.canvasWidth;
      cachedCtx.canvas.height = this.canvasHeight;

      // copy current image from ctx (resize)
      if (lastWidth && lastHeight) {
        cachedCtx.drawImage(ctx.canvas, 0, 0, lastWidth, lastHeight, 0, 0, this.canvasWidth, this.canvasHeight);
      }

      ctx.canvas.width = this.canvasWidth;
      ctx.canvas.height = this.canvasHeight;
      ctx.canvas.style.width = width + 'px';
      ctx.canvas.style.height = height + 'px';

      // update scale
      this._setYScale();
    }

    /**
     * Create the transfert function used to map values to pixel in the y axis
     * @private
     */

  }, {
    key: '_setYScale',
    value: function _setYScale() {
      var min = this.params.get('min');
      var max = this.params.get('max');
      var height = this.canvasHeight;

      var a = (0 - height) / (max - min);
      var b = height - a * min;

      this.getYPosition = function (x) {
        return a * x + b;
      };
    }

    /**
     * Returns the width in pixel a `vector` frame needs to be drawn.
     * @private
     */

  }, {
    key: 'getMinimumFrameWidth',
    value: function getMinimumFrameWidth() {
      return 1; // need one pixel to draw the line
    }

    /**
     * Callback function executed when a parameter is updated.
     *
     * @param {String} name - Parameter name.
     * @param {Mixed} value - Parameter value.
     * @param {Object} metas - Metadatas of the parameter.
     * @private
     */

  }, {
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      switch (name) {
        case 'min':
        case 'max':
          // @todo - make sure that min and max are different
          this._setYScale();
          break;
        case 'width':
        case 'height':
          this._resize();
      }
    }

    /** @private */

  }, {
    key: 'propagateStreamParams',
    value: function propagateStreamParams() {
      (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'propagateStreamParams', this).call(this);
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'resetStream', this).call(this);

      var width = this.canvasWidth;
      var height = this.canvasHeight;

      this.previousFrame = null;
      this.currentTime = this.hasDuration ? this.params.get('referenceTime') : null;

      this.ctx.clearRect(0, 0, width, height);
      this.cachedCtx.clearRect(0, 0, width, height);
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      this.currentTime = null;
      (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'finalizeStream', this).call(this, endTime);

      this._rafId = null;

      // clear the stack if not empty
      if (this._stack.length > 0) this.renderStack();
    }

    /**
     * Add the current frame to the frames to draw. Should not be overriden.
     * @private
     */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      var frameSize = this.streamParams.frameSize;
      var copy = new Float32Array(frameSize);
      var data = frame.data;

      // copy values of the input frame as they might be updated
      // in reference before being consumed in the draw function
      for (var i = 0; i < frameSize; i++) {
        copy[i] = data[i];
      }this._stack.push({
        time: frame.time,
        data: copy,
        metadata: frame.metadata
      });

      if (this._rafId === null) this._rafId = window.requestAnimationFrame(this.renderStack);
    }

    /**
     * Render the accumulated frames. Method called in `requestAnimationFrame`.
     * @private
     */

  }, {
    key: 'renderStack',
    value: function renderStack() {
      if (this.params.has('duration')) {
        // render all frame since last `renderStack` call
        for (var i = 0, l = this._stack.length; i < l; i++) {
          this.scrollModeDraw(this._stack[i]);
        }
      } else {
        // only render last received frame if any
        if (this._stack.length > 0) {
          var frame = this._stack[this._stack.length - 1];
          this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
          this.processFunction(frame);
        }
      }

      this._stack.length = 0; // reinit stack for next call
      this._rafId = null;
    }

    /**
     * Draw data from right to left with scrolling
     * @private
     * @todo - check possibility of maintaining all values from one place to
     *         minimize float error tracking.
     */

  }, {
    key: 'scrollModeDraw',
    value: function scrollModeDraw(frame) {
      var frameType = this.streamParams.frameType;
      var frameRate = this.streamParams.frameRate;
      var frameSize = this.streamParams.frameSize;
      var sourceSampleRate = this.streamParams.sourceSampleRate;

      var canvasDuration = this.params.get('duration');
      var ctx = this.ctx;
      var canvasWidth = this.canvasWidth;
      var canvasHeight = this.canvasHeight;

      var previousFrame = this.previousFrame;

      // current time at the left of the canvas
      var currentTime = this.currentTime !== null ? this.currentTime : frame.time;
      var frameStartTime = frame.time;
      var lastFrameTime = previousFrame ? previousFrame.time : 0;
      var lastFrameDuration = this.lastFrameDuration ? this.lastFrameDuration : 0;

      var frameDuration = void 0;

      if (frameType === 'scalar' || frameType === 'vector') {
        var pixelDuration = canvasDuration / canvasWidth;
        frameDuration = this.getMinimumFrameWidth() * pixelDuration;
      } else if (this.streamParams.frameType === 'signal') {
        frameDuration = frameSize / sourceSampleRate;
      }

      var frameEndTime = frameStartTime + frameDuration;
      // define if we need to shift the canvas
      var shiftTime = frameEndTime - currentTime;

      // if the canvas is not synced, should never go to `else`
      if (shiftTime > 0) {
        // shift the canvas of shiftTime in pixels
        var fShift = shiftTime / canvasDuration * canvasWidth - this.shiftError;
        var iShift = Math.floor(fShift + 0.5);
        this.shiftError = fShift - iShift;

        var _currentTime = frameStartTime + frameDuration;
        this.shiftCanvas(iShift, _currentTime);

        // if siblings, share the information
        if (this.displaySync) this.displaySync.shiftSiblings(iShift, _currentTime, this);
      }

      // width of the frame in pixels
      var floatFrameWidth = frameDuration / canvasDuration * canvasWidth;
      var frameWidth = Math.floor(floatFrameWidth + 0.5);

      // define position of the head in the canvas
      var canvasStartTime = this.currentTime - canvasDuration;
      var startTimeRatio = (frameStartTime - canvasStartTime) / canvasDuration;
      var startTimePosition = startTimeRatio * canvasWidth;

      // number of pixels since last frame
      var pixelsSinceLastFrame = this.lastFrameWidth;

      if ((frameType === 'scalar' || frameType === 'vector') && previousFrame) {
        var frameInterval = frame.time - previousFrame.time;
        pixelsSinceLastFrame = frameInterval / canvasDuration * canvasWidth;
      }

      // draw current frame
      ctx.save();
      ctx.translate(startTimePosition, 0);
      this.processFunction(frame, frameWidth, pixelsSinceLastFrame);
      ctx.restore();

      // save current canvas state into cached canvas
      this.cachedCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      this.cachedCtx.drawImage(this.canvas, 0, 0, canvasWidth, canvasHeight);

      // update lastFrameDuration, lastFrameWidth
      this.lastFrameDuration = frameDuration;
      this.lastFrameWidth = frameWidth;
      this.previousFrame = frame;
    }

    /**
     * Shift canvas, also called from `DisplaySync`
     * @private
     */

  }, {
    key: 'shiftCanvas',
    value: function shiftCanvas(iShift, time) {
      var ctx = this.ctx;
      var cache = this.cachedCanvas;
      var cachedCtx = this.cachedCtx;
      var width = this.canvasWidth;
      var height = this.canvasHeight;
      var croppedWidth = width - iShift;
      this.currentTime = time;

      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(cache, iShift, 0, croppedWidth, height, 0, 0, croppedWidth, height);
      // save current canvas state into cached canvas
      cachedCtx.clearRect(0, 0, width, height);
      cachedCtx.drawImage(this.canvas, 0, 0, width, height);
    }

    // @todo - Fix trigger mode
    // allow to witch easily between the 2 modes
    // setTrigger(bool) {
    //   this.params.trigger = bool;
    //   // clear canvas and cache
    //   this.ctx.clearRect(0, 0, this.params.width, this.params.height);
    //   this.cachedCtx.clearRect(0, 0, this.params.width, this.params.height);
    //   // reset _currentXPosition
    //   this._currentXPosition = 0;
    //   this.lastShiftError = 0;
    // }

    // /**
    //  * Alternative drawing mode.
    //  * Draw from left to right, go back to left when > width
    //  */
    // triggerModeDraw(time, frame) {
    //   const width  = this.params.width;
    //   const height = this.params.height;
    //   const duration = this.params.duration;
    //   const ctx = this.ctx;

    //   const dt = time - this.previousTime;
    //   const fShift = (dt / duration) * width - this.lastShiftError; // px
    //   const iShift = Math.round(fShift);
    //   this.lastShiftError = iShift - fShift;

    //   this.currentXPosition += iShift;

    //   // draw the right part
    //   ctx.save();
    //   ctx.translate(this.currentXPosition, 0);
    //   ctx.clearRect(-iShift, 0, iShift, height);
    //   this.drawCurve(frame, iShift);
    //   ctx.restore();

    //   // go back to the left of the canvas and redraw the same thing
    //   if (this.currentXPosition > width) {
    //     // go back to start
    //     this.currentXPosition -= width;

    //     ctx.save();
    //     ctx.translate(this.currentXPosition, 0);
    //     ctx.clearRect(-iShift, 0, iShift, height);
    //     this.drawCurve(frame, this.previousFrame, iShift);
    //     ctx.restore();
    //   }
    // }

  }]);
  return BaseDisplay;
}(_BaseLfo3.default);

exports.default = BaseDisplay;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkJhc2VEaXNwbGF5LmpzIl0sIm5hbWVzIjpbImNvbW1vbkRlZmluaXRpb25zIiwibWluIiwidHlwZSIsImRlZmF1bHQiLCJtZXRhcyIsImtpbmQiLCJtYXgiLCJ3aWR0aCIsImhlaWdodCIsImNvbnRhaW5lciIsImNvbnN0YW50IiwiY2FudmFzIiwiaGFzRHVyYXRpb25EZWZpbml0aW9ucyIsImR1cmF0aW9uIiwiSW5maW5pdHkiLCJyZWZlcmVuY2VUaW1lIiwiQmFzZURpc3BsYXkiLCJkZWZzIiwib3B0aW9ucyIsImhhc0R1cmF0aW9uIiwiY29tbW9uRGVmcyIsImRlZmluaXRpb25zIiwicGFyYW1zIiwiZ2V0IiwiRXJyb3IiLCJjYW52YXNQYXJhbSIsImNvbnRhaW5lclBhcmFtIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiY3R4IiwiZ2V0Q29udGV4dCIsImNhY2hlZENhbnZhcyIsImNhY2hlZEN0eCIsInByZXZpb3VzRnJhbWUiLCJjdXJyZW50VGltZSIsImRpc3BsYXlTeW5jIiwiX3N0YWNrIiwiX3JhZklkIiwicmVuZGVyU3RhY2siLCJiaW5kIiwic2hpZnRFcnJvciIsIl9yZXNpemUiLCJkUFIiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiYlBSIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwibGFzdFdpZHRoIiwiY2FudmFzV2lkdGgiLCJsYXN0SGVpZ2h0IiwiY2FudmFzSGVpZ2h0IiwiZHJhd0ltYWdlIiwic3R5bGUiLCJfc2V0WVNjYWxlIiwiYSIsImIiLCJnZXRZUG9zaXRpb24iLCJ4IiwibmFtZSIsInZhbHVlIiwiY2xlYXJSZWN0IiwiZW5kVGltZSIsImxlbmd0aCIsImZyYW1lIiwiZnJhbWVTaXplIiwic3RyZWFtUGFyYW1zIiwiY29weSIsIkZsb2F0MzJBcnJheSIsImRhdGEiLCJpIiwicHVzaCIsInRpbWUiLCJtZXRhZGF0YSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhcyIsImwiLCJzY3JvbGxNb2RlRHJhdyIsInByb2Nlc3NGdW5jdGlvbiIsImZyYW1lVHlwZSIsImZyYW1lUmF0ZSIsInNvdXJjZVNhbXBsZVJhdGUiLCJjYW52YXNEdXJhdGlvbiIsImZyYW1lU3RhcnRUaW1lIiwibGFzdEZyYW1lVGltZSIsImxhc3RGcmFtZUR1cmF0aW9uIiwiZnJhbWVEdXJhdGlvbiIsInBpeGVsRHVyYXRpb24iLCJnZXRNaW5pbXVtRnJhbWVXaWR0aCIsImZyYW1lRW5kVGltZSIsInNoaWZ0VGltZSIsImZTaGlmdCIsImlTaGlmdCIsIk1hdGgiLCJmbG9vciIsInNoaWZ0Q2FudmFzIiwic2hpZnRTaWJsaW5ncyIsImZsb2F0RnJhbWVXaWR0aCIsImZyYW1lV2lkdGgiLCJjYW52YXNTdGFydFRpbWUiLCJzdGFydFRpbWVSYXRpbyIsInN0YXJ0VGltZVBvc2l0aW9uIiwicGl4ZWxzU2luY2VMYXN0RnJhbWUiLCJsYXN0RnJhbWVXaWR0aCIsImZyYW1lSW50ZXJ2YWwiLCJzYXZlIiwidHJhbnNsYXRlIiwicmVzdG9yZSIsImNhY2hlIiwiY3JvcHBlZFdpZHRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztBQUVBLElBQU1BLG9CQUFvQjtBQUN4QkMsT0FBSztBQUNIQyxVQUFNLE9BREg7QUFFSEMsYUFBUyxDQUFDLENBRlA7QUFHSEMsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFISixHQURtQjtBQU14QkMsT0FBSztBQUNISixVQUFNLE9BREg7QUFFSEMsYUFBUyxDQUZOO0FBR0hDLFdBQU8sRUFBRUMsTUFBTSxTQUFSO0FBSEosR0FObUI7QUFXeEJFLFNBQU87QUFDTEwsVUFBTSxTQUREO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7a0JBSWFRLFciLCJmaWxlIjoiQmFzZURpc3BsYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBjb21tb25EZWZpbml0aW9ucyA9IHtcbiAgbWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAtMSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfSxcbiAgbWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9LFxuICB9LFxuICB3aWR0aDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAzMDAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIGhlaWdodDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAxNTAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIGNvbnRhaW5lcjoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH0sXG4gIGNhbnZhczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH0sXG59O1xuXG5jb25zdCBoYXNEdXJhdGlvbkRlZmluaXRpb25zID0ge1xuICBkdXJhdGlvbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIHJlZmVyZW5jZVRpbWU6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH0sXG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gZXh0ZW5kIGluIG9yZGVyIHRvIGNyZWF0ZSBncmFwaGljIHNpbmtzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9UaGlzIGNsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkIGFic3RyYWN0IGFuZCBvbmx5XG4gKiBiZSB1c2VkIHRvIGJlIGV4dGVuZGVkLl88L3NwYW4+XG4gKlxuICogQHRvZG8gLSBmaXggZmxvYXQgcm91bmRpbmcgZXJyb3JzIChwcm9kdWNlIGRlY2F5cyBpbiBzeW5jIGRyYXdzKVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTFdIC0gTWluaW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gVGhpcyBwYXJhbWV0ZXIgb25seSBleGlzdHMgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbFxuICogIGNvbnNlY3V0aXZlIGZyYW1lcyBvbiB0aGUgY2FudmFzLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVmZXJlbmNlVGltZT1udWxsXSAtIE9wdGlvbm5hbCByZWZlcmVuY2UgdGltZSB0aGVcbiAqICBkaXNwbGF5IHNob3VsZCBjb25zaWRlcmVyIGFzIHRoZSBvcmlnaW4uIElzIG9ubHkgdXNlZnVsbCB3aGVuIHN5bmNocm9uaXppbmdcbiAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuIFRoaXMgcGFyYW1ldGVyIG9ubHkgZXhpc3RzXG4gKiAgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbCBjb25zZWN1dGl2ZSBmcmFtZXMgb24gdGhlIGNhbnZhcy5cbiAqL1xuY2xhc3MgQmFzZURpc3BsYXkgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3IoZGVmcywgb3B0aW9ucyA9IHt9LCBoYXNEdXJhdGlvbiA9IHRydWUpIHtcbiAgICBsZXQgY29tbW9uRGVmcztcblxuICAgIGlmIChoYXNEdXJhdGlvbilcbiAgICAgIGNvbW1vbkRlZnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21tb25EZWZpbml0aW9ucywgaGFzRHVyYXRpb25EZWZpbml0aW9ucyk7XG4gICAgZWxzZVxuICAgICAgY29tbW9uRGVmcyA9IGNvbW1vbkRlZmluaXRpb25zXG5cbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbW1vbkRlZnMsIGRlZnMpO1xuXG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zLmdldCgnY2FudmFzJykgPT09IG51bGwgJiYgdGhpcy5wYXJhbXMuZ2V0KCdjb250YWluZXInKSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6IGBjYW52YXNgIG9yIGBjb250YWluZXJgIG5vdCBkZWZpbmVkJyk7XG5cbiAgICBjb25zdCBjYW52YXNQYXJhbSA9IHRoaXMucGFyYW1zLmdldCgnY2FudmFzJyk7XG4gICAgY29uc3QgY29udGFpbmVyUGFyYW0gPSB0aGlzLnBhcmFtcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgLy8gcHJlcGFyZSBjYW52YXNcbiAgICBpZiAoY2FudmFzUGFyYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgY2FudmFzUGFyYW0gPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2FudmFzUGFyYW0pO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1BhcmFtO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyUGFyYW0pIHtcbiAgICAgIGxldCBjb250YWluZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyUGFyYW0gPT09ICdzdHJpbmcnKVxuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lclBhcmFtKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyUGFyYW07XG5cbiAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgIH1cblxuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FjaGVkQ3R4ID0gdGhpcy5jYWNoZWRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHRoaXMuaGFzRHVyYXRpb24gPSBoYXNEdXJhdGlvbjtcbiAgICB0aGlzLnByZXZpb3VzRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSBoYXNEdXJhdGlvbiA/IHRoaXMucGFyYW1zLmdldCgncmVmZXJlbmNlVGltZScpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIHRoZSBgRGlzcGxheVN5bmNgIHVzZWQgdG8gc3luY2hyb25pemUgdGhlIGRpZmZlcmVudCBkaXNwbGF5c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kaXNwbGF5U3luYyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgICB0aGlzLl9yYWZJZCA9IG51bGw7XG5cbiAgICB0aGlzLnJlbmRlclN0YWNrID0gdGhpcy5yZW5kZXJTdGFjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2hpZnRFcnJvciA9IDA7XG5cbiAgICAvLyBpbml0aWFsaXplIGNhbnZhcyBzaXplIGFuZCB5IHNjYWxlIHRyYW5zZmVydCBmdW5jdGlvblxuICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9yZXNpemUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLnBhcmFtcy5nZXQoJ3dpZHRoJyk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5wYXJhbXMuZ2V0KCdoZWlnaHQnKTtcblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNhY2hlZEN0eCA9IHRoaXMuY2FjaGVkQ3R4O1xuXG4gICAgY29uc3QgZFBSID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICBjb25zdCBiUFIgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IGRQUiAvIGJQUjtcblxuICAgIGNvbnN0IGxhc3RXaWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgY29uc3QgbGFzdEhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzV2lkdGggPSB3aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbztcblxuICAgIGNhY2hlZEN0eC5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgIGNhY2hlZEN0eC5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQ7XG5cbiAgICAvLyBjb3B5IGN1cnJlbnQgaW1hZ2UgZnJvbSBjdHggKHJlc2l6ZSlcbiAgICBpZiAobGFzdFdpZHRoICYmIGxhc3RIZWlnaHQpIHtcbiAgICAgIGNhY2hlZEN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcyxcbiAgICAgICAgMCwgMCwgbGFzdFdpZHRoLCBsYXN0SGVpZ2h0LFxuICAgICAgICAwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjdHguY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICBjdHguY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgIGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuXG4gICAgLy8gdXBkYXRlIHNjYWxlXG4gICAgdGhpcy5fc2V0WVNjYWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0cmFuc2ZlcnQgZnVuY3Rpb24gdXNlZCB0byBtYXAgdmFsdWVzIHRvIHBpeGVsIGluIHRoZSB5IGF4aXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRZU2NhbGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW4nKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLnBhcmFtcy5nZXQoJ21heCcpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuXG4gICAgY29uc3QgYSA9ICgwIC0gaGVpZ2h0KSAvIChtYXggLSBtaW4pO1xuICAgIGNvbnN0IGIgPSBoZWlnaHQgLSAoYSAqIG1pbik7XG5cbiAgICB0aGlzLmdldFlQb3NpdGlvbiA9ICh4KSA9PiBhICogeCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWwgYSBgdmVjdG9yYCBmcmFtZSBuZWVkcyB0byBiZSBkcmF3bi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1pbmltdW1GcmFtZVdpZHRoKCkge1xuICAgIHJldHVybiAxOyAvLyBuZWVkIG9uZSBwaXhlbCB0byBkcmF3IHRoZSBsaW5lXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHBhcmFtZXRlciBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFBhcmFtZXRlciBuYW1lLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFBhcmFtZXRlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFzIC0gTWV0YWRhdGFzIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbWluJzpcbiAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgIC8vIEB0b2RvIC0gbWFrZSBzdXJlIHRoYXQgbWluIGFuZCBtYXggYXJlIGRpZmZlcmVudFxuICAgICAgICB0aGlzLl9zZXRZU2NhbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3aWR0aCc6XG4gICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvcGFnYXRlU3RyZWFtUGFyYW1zKCkge1xuICAgIHN1cGVyLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlc2V0U3RyZWFtKCkge1xuICAgIHN1cGVyLnJlc2V0U3RyZWFtKCk7XG5cbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQ7XG5cbiAgICB0aGlzLnByZXZpb3VzRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLmhhc0R1cmF0aW9uID8gdGhpcy5wYXJhbXMuZ2V0KCdyZWZlcmVuY2VUaW1lJykgOiBudWxsO1xuXG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY2FjaGVkQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG51bGw7XG4gICAgc3VwZXIuZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG5cbiAgICB0aGlzLl9yYWZJZCA9IG51bGw7XG5cbiAgICAvLyBjbGVhciB0aGUgc3RhY2sgaWYgbm90IGVtcHR5XG4gICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApXG4gICAgICB0aGlzLnJlbmRlclN0YWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBjdXJyZW50IGZyYW1lIHRvIHRoZSBmcmFtZXMgdG8gZHJhdy4gU2hvdWxkIG5vdCBiZSBvdmVycmlkZW4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3QgY29weSA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplKTtcbiAgICBjb25zdCBkYXRhID0gZnJhbWUuZGF0YTtcblxuICAgIC8vIGNvcHkgdmFsdWVzIG9mIHRoZSBpbnB1dCBmcmFtZSBhcyB0aGV5IG1pZ2h0IGJlIHVwZGF0ZWRcbiAgICAvLyBpbiByZWZlcmVuY2UgYmVmb3JlIGJlaW5nIGNvbnN1bWVkIGluIHRoZSBkcmF3IGZ1bmN0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgIGNvcHlbaV0gPSBkYXRhW2ldO1xuXG4gICAgdGhpcy5fc3RhY2sucHVzaCh7XG4gICAgICB0aW1lOiBmcmFtZS50aW1lLFxuICAgICAgZGF0YTogY29weSxcbiAgICAgIG1ldGFkYXRhOiBmcmFtZS5tZXRhZGF0YSxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9yYWZJZCA9PT0gbnVsbClcbiAgICAgIHRoaXMuX3JhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlclN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGFjY3VtdWxhdGVkIGZyYW1lcy4gTWV0aG9kIGNhbGxlZCBpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlclN0YWNrKCkge1xuICAgIGlmICh0aGlzLnBhcmFtcy5oYXMoJ2R1cmF0aW9uJykpIHtcbiAgICAgIC8vIHJlbmRlciBhbGwgZnJhbWUgc2luY2UgbGFzdCBgcmVuZGVyU3RhY2tgIGNhbGxcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fc3RhY2subGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICB0aGlzLnNjcm9sbE1vZGVEcmF3KHRoaXMuX3N0YWNrW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSByZW5kZXIgbGFzdCByZWNlaXZlZCBmcmFtZSBpZiBhbnlcbiAgICAgIGlmICh0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdGFjay5sZW5ndGggPSAwOyAvLyByZWluaXQgc3RhY2sgZm9yIG5leHQgY2FsbFxuICAgIHRoaXMuX3JhZklkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IGRhdGEgZnJvbSByaWdodCB0byBsZWZ0IHdpdGggc2Nyb2xsaW5nXG4gICAqIEBwcml2YXRlXG4gICAqIEB0b2RvIC0gY2hlY2sgcG9zc2liaWxpdHkgb2YgbWFpbnRhaW5pbmcgYWxsIHZhbHVlcyBmcm9tIG9uZSBwbGFjZSB0b1xuICAgKiAgICAgICAgIG1pbmltaXplIGZsb2F0IGVycm9yIHRyYWNraW5nLlxuICAgKi9cbiAgc2Nyb2xsTW9kZURyYXcoZnJhbWUpIHtcbiAgICBjb25zdCBmcmFtZVR5cGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGU7XG4gICAgY29uc3QgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBzb3VyY2VTYW1wbGVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZTtcblxuICAgIGNvbnN0IGNhbnZhc0R1cmF0aW9uID0gdGhpcy5wYXJhbXMuZ2V0KCdkdXJhdGlvbicpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcblxuICAgIGNvbnN0IHByZXZpb3VzRnJhbWUgPSB0aGlzLnByZXZpb3VzRnJhbWU7XG5cbiAgICAvLyBjdXJyZW50IHRpbWUgYXQgdGhlIGxlZnQgb2YgdGhlIGNhbnZhc1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKHRoaXMuY3VycmVudFRpbWUgIT09IG51bGwpID8gdGhpcy5jdXJyZW50VGltZSA6IGZyYW1lLnRpbWU7XG4gICAgY29uc3QgZnJhbWVTdGFydFRpbWUgPSBmcmFtZS50aW1lO1xuICAgIGNvbnN0IGxhc3RGcmFtZVRpbWUgPSBwcmV2aW91c0ZyYW1lID8gcHJldmlvdXNGcmFtZS50aW1lIDogMDtcbiAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9IHRoaXMubGFzdEZyYW1lRHVyYXRpb24gPyB0aGlzLmxhc3RGcmFtZUR1cmF0aW9uIDogMDtcblxuICAgIGxldCBmcmFtZUR1cmF0aW9uO1xuXG4gICAgaWYgKGZyYW1lVHlwZSA9PT0gJ3NjYWxhcicgfHwgZnJhbWVUeXBlID09PSAndmVjdG9yJykge1xuICAgICAgY29uc3QgcGl4ZWxEdXJhdGlvbiA9IGNhbnZhc0R1cmF0aW9uIC8gY2FudmFzV2lkdGg7XG4gICAgICBmcmFtZUR1cmF0aW9uID0gdGhpcy5nZXRNaW5pbXVtRnJhbWVXaWR0aCgpICogcGl4ZWxEdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9PT0gJ3NpZ25hbCcpIHtcbiAgICAgIGZyYW1lRHVyYXRpb24gPSBmcmFtZVNpemUgLyBzb3VyY2VTYW1wbGVSYXRlO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYW1lRW5kVGltZSA9IGZyYW1lU3RhcnRUaW1lICsgZnJhbWVEdXJhdGlvbjtcbiAgICAvLyBkZWZpbmUgaWYgd2UgbmVlZCB0byBzaGlmdCB0aGUgY2FudmFzXG4gICAgY29uc3Qgc2hpZnRUaW1lID0gZnJhbWVFbmRUaW1lIC0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBpZiB0aGUgY2FudmFzIGlzIG5vdCBzeW5jZWQsIHNob3VsZCBuZXZlciBnbyB0byBgZWxzZWBcbiAgICBpZiAoc2hpZnRUaW1lID4gMCkge1xuICAgICAgLy8gc2hpZnQgdGhlIGNhbnZhcyBvZiBzaGlmdFRpbWUgaW4gcGl4ZWxzXG4gICAgICBjb25zdCBmU2hpZnQgPSAoc2hpZnRUaW1lIC8gY2FudmFzRHVyYXRpb24pICogY2FudmFzV2lkdGggLSB0aGlzLnNoaWZ0RXJyb3I7XG4gICAgICBjb25zdCBpU2hpZnQgPSBNYXRoLmZsb29yKGZTaGlmdCArIDAuNSk7XG4gICAgICB0aGlzLnNoaWZ0RXJyb3IgPSBmU2hpZnQgLSBpU2hpZnQ7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gZnJhbWVTdGFydFRpbWUgKyBmcmFtZUR1cmF0aW9uO1xuICAgICAgdGhpcy5zaGlmdENhbnZhcyhpU2hpZnQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gaWYgc2libGluZ3MsIHNoYXJlIHRoZSBpbmZvcm1hdGlvblxuICAgICAgaWYgKHRoaXMuZGlzcGxheVN5bmMpXG4gICAgICAgIHRoaXMuZGlzcGxheVN5bmMuc2hpZnRTaWJsaW5ncyhpU2hpZnQsIGN1cnJlbnRUaW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyB3aWR0aCBvZiB0aGUgZnJhbWUgaW4gcGl4ZWxzXG4gICAgY29uc3QgZmxvYXRGcmFtZVdpZHRoID0gKGZyYW1lRHVyYXRpb24gLyBjYW52YXNEdXJhdGlvbikgKiBjYW52YXNXaWR0aDtcbiAgICBjb25zdCBmcmFtZVdpZHRoID0gTWF0aC5mbG9vcihmbG9hdEZyYW1lV2lkdGggKyAwLjUpO1xuXG4gICAgLy8gZGVmaW5lIHBvc2l0aW9uIG9mIHRoZSBoZWFkIGluIHRoZSBjYW52YXNcbiAgICBjb25zdCBjYW52YXNTdGFydFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lIC0gY2FudmFzRHVyYXRpb247XG4gICAgY29uc3Qgc3RhcnRUaW1lUmF0aW8gPSAoZnJhbWVTdGFydFRpbWUgLSBjYW52YXNTdGFydFRpbWUpIC8gY2FudmFzRHVyYXRpb247XG4gICAgY29uc3Qgc3RhcnRUaW1lUG9zaXRpb24gPSBzdGFydFRpbWVSYXRpbyAqIGNhbnZhc1dpZHRoO1xuXG4gICAgLy8gbnVtYmVyIG9mIHBpeGVscyBzaW5jZSBsYXN0IGZyYW1lXG4gICAgbGV0IHBpeGVsc1NpbmNlTGFzdEZyYW1lID0gdGhpcy5sYXN0RnJhbWVXaWR0aDtcblxuICAgIGlmICgoZnJhbWVUeXBlID09PSAnc2NhbGFyJyB8fCBmcmFtZVR5cGUgPT09ICd2ZWN0b3InKSAmJiBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICBjb25zdCBmcmFtZUludGVydmFsID0gZnJhbWUudGltZSAtIHByZXZpb3VzRnJhbWUudGltZTtcbiAgICAgIHBpeGVsc1NpbmNlTGFzdEZyYW1lID0gKGZyYW1lSW50ZXJ2YWwgLyBjYW52YXNEdXJhdGlvbikgKiBjYW52YXNXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBkcmF3IGN1cnJlbnQgZnJhbWVcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUoc3RhcnRUaW1lUG9zaXRpb24sIDApO1xuICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lLCBmcmFtZVdpZHRoLCBwaXhlbHNTaW5jZUxhc3RGcmFtZSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vIHNhdmUgY3VycmVudCBjYW52YXMgc3RhdGUgaW50byBjYWNoZWQgY2FudmFzXG4gICAgdGhpcy5jYWNoZWRDdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIHRoaXMuY2FjaGVkQ3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG5cbiAgICAvLyB1cGRhdGUgbGFzdEZyYW1lRHVyYXRpb24sIGxhc3RGcmFtZVdpZHRoXG4gICAgdGhpcy5sYXN0RnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5sYXN0RnJhbWVXaWR0aCA9IGZyYW1lV2lkdGg7XG4gICAgdGhpcy5wcmV2aW91c0ZyYW1lID0gZnJhbWU7XG4gIH1cblxuICAvKipcbiAgICogU2hpZnQgY2FudmFzLCBhbHNvIGNhbGxlZCBmcm9tIGBEaXNwbGF5U3luY2BcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNoaWZ0Q2FudmFzKGlTaGlmdCwgdGltZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZWRDYW52YXM7XG4gICAgY29uc3QgY2FjaGVkQ3R4ID0gdGhpcy5jYWNoZWRDdHg7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgIGNvbnN0IGNyb3BwZWRXaWR0aCA9IHdpZHRoIC0gaVNoaWZ0O1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aW1lO1xuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHguZHJhd0ltYWdlKGNhY2hlLCBpU2hpZnQsIDAsIGNyb3BwZWRXaWR0aCwgaGVpZ2h0LCAwLCAwLCBjcm9wcGVkV2lkdGgsIGhlaWdodCk7XG4gICAgLy8gc2F2ZSBjdXJyZW50IGNhbnZhcyBzdGF0ZSBpbnRvIGNhY2hlZCBjYW52YXNcbiAgICBjYWNoZWRDdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNhY2hlZEN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgLy8gQHRvZG8gLSBGaXggdHJpZ2dlciBtb2RlXG4gIC8vIGFsbG93IHRvIHdpdGNoIGVhc2lseSBiZXR3ZWVuIHRoZSAyIG1vZGVzXG4gIC8vIHNldFRyaWdnZXIoYm9vbCkge1xuICAvLyAgIHRoaXMucGFyYW1zLnRyaWdnZXIgPSBib29sO1xuICAvLyAgIC8vIGNsZWFyIGNhbnZhcyBhbmQgY2FjaGVcbiAgLy8gICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5wYXJhbXMud2lkdGgsIHRoaXMucGFyYW1zLmhlaWdodCk7XG4gIC8vICAgdGhpcy5jYWNoZWRDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMucGFyYW1zLndpZHRoLCB0aGlzLnBhcmFtcy5oZWlnaHQpO1xuICAvLyAgIC8vIHJlc2V0IF9jdXJyZW50WFBvc2l0aW9uXG4gIC8vICAgdGhpcy5fY3VycmVudFhQb3NpdGlvbiA9IDA7XG4gIC8vICAgdGhpcy5sYXN0U2hpZnRFcnJvciA9IDA7XG4gIC8vIH1cblxuICAvLyAvKipcbiAgLy8gICogQWx0ZXJuYXRpdmUgZHJhd2luZyBtb2RlLlxuICAvLyAgKiBEcmF3IGZyb20gbGVmdCB0byByaWdodCwgZ28gYmFjayB0byBsZWZ0IHdoZW4gPiB3aWR0aFxuICAvLyAgKi9cbiAgLy8gdHJpZ2dlck1vZGVEcmF3KHRpbWUsIGZyYW1lKSB7XG4gIC8vICAgY29uc3Qgd2lkdGggID0gdGhpcy5wYXJhbXMud2lkdGg7XG4gIC8vICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuICAvLyAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wYXJhbXMuZHVyYXRpb247XG4gIC8vICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgLy8gICBjb25zdCBkdCA9IHRpbWUgLSB0aGlzLnByZXZpb3VzVGltZTtcbiAgLy8gICBjb25zdCBmU2hpZnQgPSAoZHQgLyBkdXJhdGlvbikgKiB3aWR0aCAtIHRoaXMubGFzdFNoaWZ0RXJyb3I7IC8vIHB4XG4gIC8vICAgY29uc3QgaVNoaWZ0ID0gTWF0aC5yb3VuZChmU2hpZnQpO1xuICAvLyAgIHRoaXMubGFzdFNoaWZ0RXJyb3IgPSBpU2hpZnQgLSBmU2hpZnQ7XG5cbiAgLy8gICB0aGlzLmN1cnJlbnRYUG9zaXRpb24gKz0gaVNoaWZ0O1xuXG4gIC8vICAgLy8gZHJhdyB0aGUgcmlnaHQgcGFydFxuICAvLyAgIGN0eC5zYXZlKCk7XG4gIC8vICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmN1cnJlbnRYUG9zaXRpb24sIDApO1xuICAvLyAgIGN0eC5jbGVhclJlY3QoLWlTaGlmdCwgMCwgaVNoaWZ0LCBoZWlnaHQpO1xuICAvLyAgIHRoaXMuZHJhd0N1cnZlKGZyYW1lLCBpU2hpZnQpO1xuICAvLyAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gICAvLyBnbyBiYWNrIHRvIHRoZSBsZWZ0IG9mIHRoZSBjYW52YXMgYW5kIHJlZHJhdyB0aGUgc2FtZSB0aGluZ1xuICAvLyAgIGlmICh0aGlzLmN1cnJlbnRYUG9zaXRpb24gPiB3aWR0aCkge1xuICAvLyAgICAgLy8gZ28gYmFjayB0byBzdGFydFxuICAvLyAgICAgdGhpcy5jdXJyZW50WFBvc2l0aW9uIC09IHdpZHRoO1xuXG4gIC8vICAgICBjdHguc2F2ZSgpO1xuICAvLyAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmN1cnJlbnRYUG9zaXRpb24sIDApO1xuICAvLyAgICAgY3R4LmNsZWFyUmVjdCgtaVNoaWZ0LCAwLCBpU2hpZnQsIGhlaWdodCk7XG4gIC8vICAgICB0aGlzLmRyYXdDdXJ2ZShmcmFtZSwgdGhpcy5wcmV2aW91c0ZyYW1lLCBpU2hpZnQpO1xuICAvLyAgICAgY3R4LnJlc3RvcmUoKTtcbiAgLy8gICB9XG4gIC8vIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlRGlzcGxheTtcbiJdfQ==