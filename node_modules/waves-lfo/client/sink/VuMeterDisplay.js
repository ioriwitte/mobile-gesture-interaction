'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _log = require('babel-runtime/core-js/math/log10');

var _log2 = _interopRequireDefault(_log);

var _BaseDisplay2 = require('./BaseDisplay');

var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);

var _Rms = require('../../common/operator/Rms');

var _Rms2 = _interopRequireDefault(_Rms);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log10 = _log2.default;

var definitions = {
  offset: {
    type: 'float',
    default: -14,
    metas: { kind: 'dyanmic' }
  },
  min: {
    type: 'float',
    default: -80,
    metas: { kind: 'dynamic' }
  },
  max: {
    type: 'float',
    default: 6,
    metas: { kind: 'dynamic' }
  },
  width: {
    type: 'integer',
    default: 6,
    metas: { kind: 'dynamic' }
  }

  /**
   * Simple VU-Meter to used on a `signal` stream.
   *
   * @memberof module:client.sink
   *
   * @param {Object} options - Override defaults parameters.
   * @param {Number} [options.offset=-14] - dB offset applied to the signal.
   * @param {Number} [options.min=-80] - Minimum displayed value (in dB).
   * @param {Number} [options.max=6] - Maximum displayed value (in dB).
   * @param {Number} [options.width=6] - Width of the display (in pixels).
   * @param {Number} [options.height=150] - Height of the canvas.
   * @param {Element|CSSSelector} [options.container=null] - Container element
   *  in which to insert the canvas.
   * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
   *  in which to draw.
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * const audioContext = new window.AudioContext();
   *
   * navigator.mediaDevices
   *   .getUserMedia({ audio: true })
   *   .then(init)
   *   .catch((err) => console.error(err.stack));
   *
   * function init(stream) {
   *   const source = audioContext.createMediaStreamSource(stream);
   *
   *   const audioInNode = new lfo.source.AudioInNode({
   *     audioContext: audioContext,
   *     sourceNode: source,
   *   });
   *
   *   const vuMeter = new lfo.sink.VuMeterDisplay({
   *     canvas: '#vu-meter',
   *   });
   *
   *   audioInNode.connect(vuMeter);
   *   audioInNode.start();
   * }
   */
};
var VuMeterDisplay = function (_BaseDisplay) {
  (0, _inherits3.default)(VuMeterDisplay, _BaseDisplay);

  function VuMeterDisplay() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, VuMeterDisplay);

    var _this = (0, _possibleConstructorReturn3.default)(this, (VuMeterDisplay.__proto__ || (0, _getPrototypeOf2.default)(VuMeterDisplay)).call(this, definitions, options, false));

    _this.rmsOperator = new _Rms2.default();

    _this.lastDB = 0;
    _this.peak = {
      value: 0,
      time: 0
    };

    _this.peakLifetime = 1; // sec
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(VuMeterDisplay, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.rmsOperator.initStream(this.streamParams);

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      var now = new Date().getTime() / 1000; // sec
      var offset = this.params.get('offset'); // offset zero of the vu meter
      var height = this.canvasHeight;
      var width = this.canvasWidth;
      var ctx = this.ctx;

      var lastDB = this.lastDB;
      var peak = this.peak;

      var red = '#ff2121';
      var yellow = '#ffff1f';
      var green = '#00ff00';

      // handle current db value
      var rms = this.rmsOperator.inputSignal(frame.data);
      var dB = 20 * log10(rms) - offset;

      // slow release (could probably be improved)
      if (lastDB > dB) dB = lastDB - 6;

      // handle peak
      if (dB > peak.value || now - peak.time > this.peakLifetime) {
        peak.value = dB;
        peak.time = now;
      }

      var y0 = this.getYPosition(0);
      var y = this.getYPosition(dB);
      var yPeak = this.getYPosition(peak.value);

      ctx.save();

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      var gradient = ctx.createLinearGradient(0, height, 0, 0);
      gradient.addColorStop(0, green);
      gradient.addColorStop((height - y0) / height, yellow);
      gradient.addColorStop(1, red);

      // dB
      ctx.fillStyle = gradient;
      ctx.fillRect(0, y, width, height - y);

      // 0 dB marker
      ctx.fillStyle = '#dcdcdc';
      ctx.fillRect(0, y0, width, 2);

      // peak
      ctx.fillStyle = gradient;
      ctx.fillRect(0, yPeak, width, 2);

      ctx.restore();

      this.lastDB = dB;
    }
  }]);
  return VuMeterDisplay;
}(_BaseDisplay3.default);

exports.default = VuMeterDisplay;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZ1TWV0ZXJEaXNwbGF5LmpzIl0sIm5hbWVzIjpbImxvZzEwIiwiZGVmaW5pdGlvbnMiLCJvZmZzZXQiLCJ0eXBlIiwiZGVmYXVsdCIsIm1ldGFzIiwia2luZCIsIm1pbiIsIm1heCIsIndpZHRoIiwiVnVNZXRlckRpc3BsYXkiLCJvcHRpb25zIiwicm1zT3BlcmF0b3IiLCJsYXN0REIiLCJwZWFrIiwidmFsdWUiLCJ0aW1lIiwicGVha0xpZmV0aW1lIiwicHJldlN0cmVhbVBhcmFtcyIsInByZXBhcmVTdHJlYW1QYXJhbXMiLCJpbml0U3RyZWFtIiwic3RyZWFtUGFyYW1zIiwicHJvcGFnYXRlU3RyZWFtUGFyYW1zIiwiZnJhbWUiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInBhcmFtcyIsImdldCIsImhlaWdodCIsImNhbnZhc0hlaWdodCIsImNhbnZhc1dpZHRoIiwiY3R4IiwicmVkIiwieWVsbG93IiwiZ3JlZW4iLCJybXMiLCJpbnB1dFNpZ25hbCIsImRhdGEiLCJkQiIsInkwIiwiZ2V0WVBvc2l0aW9uIiwieSIsInlQZWFrIiwic2F2ZSIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInJlc3RvcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLHFCQUFOOztBQUVBLElBQU1DLGNBQWM7QUFDbEJDLFVBQVE7QUFDTkMsVUFBTSxPQURBO0FBRU5DLGFBQVMsQ0FBQyxFQUZKO0FBR05DLFdBQU8sRUFBRUMsTUFBTSxTQUFSO0FBSEQsR0FEVTtBQU1sQkMsT0FBSztBQUNISixVQUFNLE9BREg7QUFFSEMsYUFBUyxDQUFDLEVBRlA7QUFHSEMsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFISixHQU5hO0FBV2xCRSxPQUFLO0FBQ0hMLFVBQU0sT0FESDtBQUVIQyxhQUFTLENBRk47QUFHSEMs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LFFBQUosQ0FBYSxDQUFiLEVBQWdCSixDQUFoQixFQUFtQmpDLEtBQW5CLEVBQTBCb0IsU0FBU2EsQ0FBbkM7O0FBRUE7QUFDQVYsVUFBSWEsU0FBSixHQUFnQixTQUFoQjtBQUNBYixVQUFJYyxRQUFKLENBQWEsQ0FBYixFQUFnQk4sRUFBaEIsRUFBb0IvQixLQUFwQixFQUEyQixDQUEzQjs7QUFFQTtBQUNBdUIsVUFBSWEsU0FBSixHQUFnQkUsUUFBaEI7QUFDQWYsVUFBSWMsUUFBSixDQUFhLENBQWIsRUFBZ0JILEtBQWhCLEVBQXVCbEMsS0FBdkIsRUFBOEIsQ0FBOUI7O0FBRUF1QixVQUFJa0IsT0FBSjs7QUFFQSxXQUFLckMsTUFBTCxHQUFjMEIsRUFBZDtBQUNEOzs7OztrQkFHWTdCLGMiLCJmaWxlIjoiVnVNZXRlckRpc3BsYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURpc3BsYXkgZnJvbSAnLi9CYXNlRGlzcGxheSc7XG5pbXBvcnQgUm1zIGZyb20gJy4uLy4uL2NvbW1vbi9vcGVyYXRvci9SbXMnO1xuXG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBvZmZzZXQ6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IC0xNCxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgbWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAtODAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIG1heDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogNixcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfSxcbiAgd2lkdGg6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogNixcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBWVS1NZXRlciB0byB1c2VkIG9uIGEgYHNpZ25hbGAgc3RyZWFtLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHRzIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PS0xNF0gLSBkQiBvZmZzZXQgYXBwbGllZCB0byB0aGUgc2lnbmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbj0tODBdIC0gTWluaW11bSBkaXNwbGF5ZWQgdmFsdWUgKGluIGRCKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9Nl0gLSBNYXhpbXVtIGRpc3BsYXllZCB2YWx1ZSAoaW4gZEIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTZdIC0gV2lkdGggb2YgdGhlIGRpc3BsYXkgKGluIHBpeGVscykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTE1MF0gLSBIZWlnaHQgb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbiAqXG4gKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gKiAgIC5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxuICogICAudGhlbihpbml0KVxuICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAqXG4gKiBmdW5jdGlvbiBpbml0KHN0cmVhbSkge1xuICogICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAqXG4gKiAgIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogICAgIHNvdXJjZU5vZGU6IHNvdXJjZSxcbiAqICAgfSk7XG4gKlxuICogICBjb25zdCB2dU1ldGVyID0gbmV3IGxmby5zaW5rLlZ1TWV0ZXJEaXNwbGF5KHtcbiAqICAgICBjYW52YXM6ICcjdnUtbWV0ZXInLFxuICogICB9KTtcbiAqXG4gKiAgIGF1ZGlvSW5Ob2RlLmNvbm5lY3QodnVNZXRlcik7XG4gKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKiB9XG4gKi9cbmNsYXNzIFZ1TWV0ZXJEaXNwbGF5IGV4dGVuZHMgQmFzZURpc3BsYXkge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucywgZmFsc2UpO1xuXG4gICAgdGhpcy5ybXNPcGVyYXRvciA9IG5ldyBSbXMoKTtcblxuICAgIHRoaXMubGFzdERCID0gMDtcbiAgICB0aGlzLnBlYWsgPSB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIHRpbWU6IDAsXG4gICAgfVxuXG4gICAgdGhpcy5wZWFrTGlmZXRpbWUgPSAxOyAvLyBzZWNcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICB0aGlzLnJtc09wZXJhdG9yLmluaXRTdHJlYW0odGhpcy5zdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwOyAvLyBzZWNcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnBhcmFtcy5nZXQoJ29mZnNldCcpOyAvLyBvZmZzZXQgemVybyBvZiB0aGUgdnUgbWV0ZXJcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBsYXN0REIgPSB0aGlzLmxhc3REQjtcbiAgICBjb25zdCBwZWFrID0gdGhpcy5wZWFrO1xuXG4gICAgY29uc3QgcmVkID0gJyNmZjIxMjEnO1xuICAgIGNvbnN0IHllbGxvdyA9ICcjZmZmZjFmJztcbiAgICBjb25zdCBncmVlbiA9ICcjMDBmZjAwJztcblxuICAgIC8vIGhhbmRsZSBjdXJyZW50IGRiIHZhbHVlXG4gICAgY29uc3Qgcm1zID0gdGhpcy5ybXNPcGVyYXRvci5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgICBsZXQgZEIgPSAyMCAqIGxvZzEwKHJtcykgLSBvZmZzZXQ7XG5cbiAgICAvLyBzbG93IHJlbGVhc2UgKGNvdWxkIHByb2JhYmx5IGJlIGltcHJvdmVkKVxuICAgIGlmIChsYXN0REIgPiBkQilcbiAgICAgIGRCID0gbGFzdERCIC0gNjtcblxuICAgIC8vIGhhbmRsZSBwZWFrXG4gICAgaWYgKGRCID4gcGVhay52YWx1ZSB8fMKgKG5vdyAtIHBlYWsudGltZSkgPiB0aGlzLnBlYWtMaWZldGltZSkge1xuICAgICAgcGVhay52YWx1ZSA9IGRCO1xuICAgICAgcGVhay50aW1lID0gbm93O1xuICAgIH1cblxuICAgIGNvbnN0IHkwID0gdGhpcy5nZXRZUG9zaXRpb24oMCk7XG4gICAgY29uc3QgeSA9IHRoaXMuZ2V0WVBvc2l0aW9uKGRCKTtcbiAgICBjb25zdCB5UGVhayA9IHRoaXMuZ2V0WVBvc2l0aW9uKHBlYWsudmFsdWUpO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgaGVpZ2h0LCAwLCAwKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgZ3JlZW4pO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgoaGVpZ2h0IC0geTApIC8gaGVpZ2h0LCB5ZWxsb3cpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCByZWQpO1xuXG4gICAgLy8gZEJcbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KDAsIHksIHdpZHRoLCBoZWlnaHQgLSB5KTtcblxuICAgIC8vIDAgZEIgbWFya2VyXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZGNkY2RjJztcbiAgICBjdHguZmlsbFJlY3QoMCwgeTAsIHdpZHRoLCAyKTtcblxuICAgIC8vIHBlYWtcbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KDAsIHlQZWFrLCB3aWR0aCwgMik7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgdGhpcy5sYXN0REIgPSBkQjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWdU1ldGVyRGlzcGxheTtcbiJdfQ==