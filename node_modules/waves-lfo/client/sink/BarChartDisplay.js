'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseDisplay2 = require('./BaseDisplay');

var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);

var _Fft = require('../../common/operator/Fft');

var _Fft2 = _interopRequireDefault(_Fft);

var _displayUtils = require('../utils/display-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  scale: {
    type: 'float',
    default: 1,
    metas: { kind: 'dynamic' }
  },
  colors: {
    type: 'any',
    default: (0, _displayUtils.getColors)('bar-chart'),
    nullable: true,
    metas: { kind: 'dynamic' }
  },
  min: {
    type: 'float',
    default: 0,
    metas: { kind: 'dynamic' }
  },
  max: {
    type: 'float',
    default: 1,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Display a bar chart from an incomming `vector` input.
 *
 * @memberof module:client.sink
 *
 * @param {Object} options - Override default parameters.
 * @param {String} [options.colors=null] - Colors of the bars.
 * @param {Number} [options.min=-80] - Minimum displayed value.
 * @param {Number} [options.max=6] - Maximum displayed value.
 * @param {Number} [options.width=300] - Width of the canvas.
 *  _dynamic parameter_
 * @param {Number} [options.height=150] - Height of the canvas.
 *  _dynamic parameter_
 * @param {Element|CSSSelector} [options.container=null] - Container element
 *  in which to insert the canvas. _constant parameter_
 * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
 *  in which to draw. _constant parameter_
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 * import * as lfo from 'waves-lfo/client';
 *
 * const frameSize = 5;
 * const dt = 0.02;
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameSize: frameSize,
 *   frameRate: 1 / dt,
 *   frameType: 'vector',
 * });
 *
 * const barChart = new lfo.sink.BarChartDisplay({
 *   canvas: '#bar-chart',
 * });
 *
 * eventIn.connect(barChart);
 * eventIn.start();
 *
 * const data = [0, 0.2, 0.4, 0.6, 0.8];
 *
 * (function generateData() {
 *   for (let i = 0; i < frameSize; i++)
 *     data[i] = (data[i] + 0.001) % 1;
 *
 *   eventIn.process(null, data);
 *
 *   setTimeout(generateData, dt * 1000);
 * }());
 */

var BarChartDisplay = function (_BaseDisplay) {
  (0, _inherits3.default)(BarChartDisplay, _BaseDisplay);

  function BarChartDisplay() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, BarChartDisplay);
    return (0, _possibleConstructorReturn3.default)(this, (BarChartDisplay.__proto__ || (0, _getPrototypeOf2.default)(BarChartDisplay)).call(this, definitions, options, false));
  }

  /** @private */


  (0, _createClass3.default)(BarChartDisplay, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);
      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      var frameSize = this.streamParams.frameSize;
      var width = this.canvasWidth;
      var height = this.canvasHeight;
      var colors = this.params.get('colors');
      var data = frame.data;

      var barWidth = width / frameSize;
      var ctx = this.ctx;

      // error handling needs review...
      var error = 0;

      for (var i = 0; i < frameSize; i++) {
        var x1Float = i * barWidth + error;
        var x1Int = Math.round(x1Float);
        var x2Float = x1Float + (barWidth - error);
        var x2Int = Math.round(x2Float);

        error = x2Int - x2Float;

        if (x1Int !== x2Int) {
          var _width = x2Int - x1Int;
          var y = this.getYPosition(data[i]);

          ctx.fillStyle = colors[i % colors.length];
          ctx.fillRect(x1Int, y, _width, height - y);
        } else {
          error -= barWidth;
        }
      }
    }
  }]);
  return BarChartDisplay;
}(_BaseDisplay3.default);

exports.default = BarChartDisplay;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkJhckNoYXJ0RGlzcGxheS5qcyJdLCJuYW1lcyI6WyJkZWZpbml0aW9ucyIsInNjYWxlIiwidHlwZSIsImRlZmF1bHQiLCJtZXRhcyIsImtpbmQiLCJjb2xvcnMiLCJudWxsYWJsZSIsIm1pbiIsIm1heCIsIkJhckNoYXJ0RGlzcGxheSIsIm9wdGlvbnMiLCJwcmV2U3RyZWFtUGFyYW1zIiwicHJlcGFyZVN0cmVhbVBhcmFtcyIsInByb3BhZ2F0ZVN0cmVhbVBhcmFtcyIsImZyYW1lIiwiZnJhbWVTaXplIiwic3RyZWFtUGFyYW1zIiwid2lkdGgiLCJjYW52YXNXaWR0aCIsImhlaWdodCIsImNhbnZhc0hlaWdodCIsInBhcmFtcyIsImdldCIsImRhdGEiLCJiYXJXaWR0aCIsImN0eCIsImVycm9yIiwiaSIsIngxRmxvYXQiLCJ4MUludCIsIk1hdGgiLCJyb3VuZCIsIngyRmxvYXQiLCJ4MkludCIsInkiLCJnZXRZUG9zaXRpb24iLCJmaWxsU3R5bGUiLCJsZW5ndGgiLCJmaWxsUmVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQSxJQUFNQSxjQUFjO0FBQ2xCQyxTQUFPO0FBQ0xDLFVBQU0sT0FERDtBQUVMQyxhQUFTLENBRko7QUFHTEMsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFIRixHQURXO0FBTWxCQyxVQUFRO0FBQ05KLFVBQU0sS0FEQTtBQUVOQyxhQUFTLDZCQUFVLFdBQVYsQ0FGSDtBQUdOSSxjQUFVLElBSEo7QUFJTkgsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFKRCxHQU5VO0FBWWxCRyxPQUFLO0FBQ0hOLFVBQU0sT0FESDtBQUVIQyxhQUFTLENBRk47QUFHSEMsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFISixHQVphO0FBaUJsQkksT0FBSztBQUNIUCxVQUFNLE9BREg7QUFFSEMsYUFBUyxDQUZOO0FBR0hDLFdBQU8sRUFBRUMsTUFBTSxTQUFSO0FBSEo7QUFqQmEsQ0FBcEI7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWlETUssZTs7O0FBQ0osNkJBQTBCO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7QUFBQSxtSkFDbEJYLFdBRGtCLEVBQ0xXLE9BREssRUFDSSxLQURKO0FBRXpCOztBQUVEOzs7Ozt3Q0FDb0JDLGdCLEVBQWtCO0FBQ3BDLFdBQUtDLG1CQUFMLENBQXlCRCxnQkFBekI7QUFDQSxXQUFLRSxxQkFBTDtBQUNEOztBQUVEOzs7O2tDQUNjQyxLLEVBQU87QUFDbkIsVUFBTUMsWUFBWSxLQUFLQyxZQUFMLENBQWtCRCxTQUFwQztBQUNBLFVBQU1FLFFBQVEsS0FBS0MsV0FBbkI7QUFDQSxVQUFNQyxTQUFTLEtBQUtDLFlBQXBCO0FBQ0EsVUFBTWYsU0FBUyxLQUFLZ0IsTUFBTCxDQUFZQyxHQUFaLENBQWdCLFFBQWhCLENBQWY7QUFDQSxVQUFNQyxPQUFPVCxNQUFNUyxJQUFuQjs7QUFFQSxVQUFNQyxXQUFXUCxRQUFRRixTQUF6QjtBQUNBLFVBQU1VLE1BQU0sS0FBS0EsR0FBakI7O0FBRUE7QUFDQSxVQUFJQyxRQUFRLENBQVo7O0FBRUEsV0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlaLFNBQXBCLEVBQStCWSxHQUEvQixFQUFvQztBQUNsQyxZQUFNQyxVQUFVRCxJQUFJSCxRQUFKLEdBQWVFLEtBQS9CO0FBQ0EsWUFBTUcsUUFBUUMsS0FBS0MsS0FBTCxDQUFXSCxPQUFYLENBQWQ7QUFDQSxZQUFNSSxVQUFVSixXQUFXSixXQUFXRSxLQUF0QixDQUFoQjtBQUNBLFlBQU1PLFFBQVFILEtBQUtDLEtBQUwsQ0FBV0MsT0FBWCxDQUFkOztBQUVBTixnQkFBUU8sUUFBUUQsT0FBaEI7O0FBRUEsWUFBSUgsVUFBVUksS0FBZCxFQUFxQjtBQUNuQixjQUFNaEIsU0FBUWdCLFFBQVFKLEtBQXRCO0FBQ0EsY0FBTUssSUFBSSxLQUFLQyxZQUFMLENBQWtCWixLQUFLSSxDQUFMLENBQWxCLENBQVY7O0FBRUFGLGNBQUlXLFNBQUosR0FBZ0IvQixPQUFPc0IsSUFBSXRCLE9BQU9nQyxNQUFsQixDQUFoQjtBQUNBWixjQUFJYSxRQUFKLENBQWFULEtBQWIsRUFBb0JLLENBQXBCLEVBQXVCakIsTUFBdkIsRUFBOEJFLFNBQVNlLENBQXZDO0FBQ0QsU0FORCxNQU1PO0FBQ0xSLG1CQUFTRixRQUFUO0FBQ0Q7QUFDRjtBQUNGOzs7OztrQkFHWWYsZSIsImZpbGUiOiJCYXJDaGFydERpc3BsYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURpc3BsYXkgZnJvbSAnLi9CYXNlRGlzcGxheSc7XG5pbXBvcnQgRmZ0IGZyb20gJy4uLy4uL2NvbW1vbi9vcGVyYXRvci9GZnQnO1xuaW1wb3J0IHsgZ2V0Q29sb3JzIH0gZnJvbSAnLi4vdXRpbHMvZGlzcGxheS11dGlscyc7XG5cblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIHNjYWxlOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9LFxuICB9LFxuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBnZXRDb2xvcnMoJ2Jhci1jaGFydCcpLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9LFxuICB9LFxuICBtaW46IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIG1heDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfVxufTtcblxuXG4vKipcbiAqIERpc3BsYXkgYSBiYXIgY2hhcnQgZnJvbSBhbiBpbmNvbW1pbmcgYHZlY3RvcmAgaW5wdXQuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9ycz1udWxsXSAtIENvbG9ycyBvZiB0aGUgYmFycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTgwXSAtIE1pbmltdW0gZGlzcGxheWVkIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heD02XSAtIE1heGltdW0gZGlzcGxheWVkIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgZnJhbWVTaXplID0gNTtcbiAqIGNvbnN0IGR0ID0gMC4wMjtcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gKiAgIGZyYW1lU2l6ZTogZnJhbWVTaXplLFxuICogICBmcmFtZVJhdGU6IDEgLyBkdCxcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGJhckNoYXJ0ID0gbmV3IGxmby5zaW5rLkJhckNoYXJ0RGlzcGxheSh7XG4gKiAgIGNhbnZhczogJyNiYXItY2hhcnQnLFxuICogfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KGJhckNoYXJ0KTtcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqXG4gKiBjb25zdCBkYXRhID0gWzAsIDAuMiwgMC40LCAwLjYsIDAuOF07XG4gKlxuICogKGZ1bmN0aW9uIGdlbmVyYXRlRGF0YSgpIHtcbiAqICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAqICAgICBkYXRhW2ldID0gKGRhdGFbaV0gKyAwLjAwMSkgJSAxO1xuICpcbiAqICAgZXZlbnRJbi5wcm9jZXNzKG51bGwsIGRhdGEpO1xuICpcbiAqICAgc2V0VGltZW91dChnZW5lcmF0ZURhdGEsIGR0ICogMTAwMCk7XG4gKiB9KCkpO1xuICovXG5jbGFzcyBCYXJDaGFydERpc3BsYXkgZXh0ZW5kcyBCYXNlRGlzcGxheSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQ7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5wYXJhbXMuZ2V0KCdjb2xvcnMnKTtcbiAgICBjb25zdCBkYXRhID0gZnJhbWUuZGF0YTtcblxuICAgIGNvbnN0IGJhcldpZHRoID0gd2lkdGggLyBmcmFtZVNpemU7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAvLyBlcnJvciBoYW5kbGluZyBuZWVkcyByZXZpZXcuLi5cbiAgICBsZXQgZXJyb3IgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgY29uc3QgeDFGbG9hdCA9IGkgKiBiYXJXaWR0aCArIGVycm9yO1xuICAgICAgY29uc3QgeDFJbnQgPSBNYXRoLnJvdW5kKHgxRmxvYXQpO1xuICAgICAgY29uc3QgeDJGbG9hdCA9IHgxRmxvYXQgKyAoYmFyV2lkdGggLSBlcnJvcik7XG4gICAgICBjb25zdCB4MkludCA9IE1hdGgucm91bmQoeDJGbG9hdCk7XG5cbiAgICAgIGVycm9yID0geDJJbnQgLSB4MkZsb2F0O1xuXG4gICAgICBpZiAoeDFJbnQgIT09IHgySW50KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0geDJJbnQgLSB4MUludDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0WVBvc2l0aW9uKGRhdGFbaV0pO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcnNbaSAlIGNvbG9ycy5sZW5ndGhdO1xuICAgICAgICBjdHguZmlsbFJlY3QoeDFJbnQsIHksIHdpZHRoLCBoZWlnaHQgLSB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yIC09IGJhcldpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJDaGFydERpc3BsYXk7XG4iXX0=