'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

var _MovingAverage = require('./MovingAverage');

var _MovingAverage2 = _interopRequireDefault(_MovingAverage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var min = Math.min;
var max = Math.max;

var definitions = {
  logInput: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dyanmic' }
  },
  minInput: {
    type: 'float',
    default: 0.000000000001,
    metas: { kind: 'dyanmic' }
  },
  filterOrder: {
    type: 'integer',
    default: 5,
    metas: { kind: 'dyanmic' }
  },
  threshold: {
    type: 'float',
    default: 3,
    metas: { kind: 'dyanmic' }
  },
  offThreshold: {
    type: 'float',
    default: -Infinity,
    metas: { kind: 'dyanmic' }
  },
  minInter: {
    type: 'float',
    default: 0.050,
    metas: { kind: 'dyanmic' }
  },
  maxDuration: {
    type: 'float',
    default: Infinity,
    metas: { kind: 'dyanmic' }
  }

  /**
   * Create segments based on attacks.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters.
   * @param {Boolean} [options.logInput=false] - Apply log on the input.
   * @param {Number} [options.minInput=0.000000000001] - Minimum value to use as
   *  input.
   * @param {Number} [options.filterOrder=5] - Order of the internally used moving
   *  average.
   * @param {Number} [options.threshold=3] - Threshold that triggers a segment
   *  start.
   * @param {Number} [options.offThreshold=-Infinity] - Threshold that triggers
   *  a segment end.
   * @param {Number} [options.minInter=0.050] - Minimum delay between two semgents.
   * @param {Number} [options.maxDuration=Infinity] - Maximum duration of a segment.
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * // assuming a stream from the microphone
   * const source = audioContext.createMediaStreamSource(stream);
   *
   * const audioInNode = new lfo.source.AudioInNode({
   *   sourceNode: source,
   *   audioContext: audioContext,
   * });
   *
   * const slicer = new lfo.operator.Slicer({
   *   frameSize: frameSize,
   *   hopSize: hopSize,
   *   centeredTimeTags: true
   * });
   *
   * const power = new lfo.operator.RMS({
   *   power: true,
   * });
   *
   * const segmenter = new lfo.operator.Segmenter({
   *   logInput: true,
   *   filterOrder: 5,
   *   threshold: 3,
   *   offThreshold: -Infinity,
   *   minInter: 0.050,
   *   maxDuration: 0.050,
   * });
   *
   * const logger = new lfo.sink.Logger({ time: true });
   *
   * audioInNode.connect(slicer);
   * slicer.connect(power);
   * power.connect(segmenter);
   * segmenter.connect(logger);
   *
   * audioInNode.start();
   */
};
var Segmenter = function (_BaseLfo) {
  (0, _inherits3.default)(Segmenter, _BaseLfo);

  function Segmenter(options) {
    (0, _classCallCheck3.default)(this, Segmenter);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Segmenter.__proto__ || (0, _getPrototypeOf2.default)(Segmenter)).call(this, definitions, options));

    _this.insideSegment = false;
    _this.onsetTime = -Infinity;

    // stats
    _this.min = Infinity;
    _this.max = -Infinity;
    _this.sum = 0;
    _this.sumOfSquares = 0;
    _this.count = 0;

    var minInput = _this.params.get('minInput');
    var fill = minInput;

    if (_this.params.get('logInput') && minInput > 0) fill = Math.log(minInput);

    _this.movingAverage = new _MovingAverage2.default({
      order: _this.params.get('filterOrder'),
      fill: fill
    });

    _this.lastMvavrg = fill;
    return _this;
  }

  (0, _createClass3.default)(Segmenter, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      if (name === 'filterOrder') this.movingAverage.params.set('order', value);
    }
  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameType = 'vector';
      this.streamParams.frameSize = 5;
      this.streamParams.frameRate = 0;
      this.streamParams.description = ['duration', 'min', 'max', 'mean', 'stddev'];

      this.movingAverage.initStream(prevStreamParams);

      this.propagateStreamParams();
    }
  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'resetStream', this).call(this);
      this.movingAverage.resetStream();
      this.resetSegment();
    }
  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      if (this.insideSegment) this.outputSegment(endTime);

      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'finalizeStream', this).call(this, endTime);
    }
  }, {
    key: 'resetSegment',
    value: function resetSegment() {
      this.insideSegment = false;
      this.onsetTime = -Infinity;
      // stats
      this.min = Infinity;
      this.max = -Infinity;
      this.sum = 0;
      this.sumOfSquares = 0;
      this.count = 0;
    }
  }, {
    key: 'outputSegment',
    value: function outputSegment(endTime) {
      var outData = this.frame.data;
      outData[0] = endTime - this.onsetTime;
      outData[1] = this.min;
      outData[2] = this.max;

      var norm = 1 / this.count;
      var mean = this.sum * norm;
      var meanOfSquare = this.sumOfSquares * norm;
      var squareOfmean = mean * mean;

      outData[3] = mean;
      outData[4] = 0;

      if (meanOfSquare > squareOfmean) outData[4] = Math.sqrt(meanOfSquare - squareOfmean);

      this.frame.time = this.onsetTime;

      this.propagateFrame();
    }
  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      var logInput = this.params.get('logInput');
      var minInput = this.params.get('minInput');
      var threshold = this.params.get('threshold');
      var minInter = this.params.get('minInter');
      var maxDuration = this.params.get('maxDuration');
      var offThreshold = this.params.get('offThreshold');
      var rawValue = frame.data[0];
      var time = frame.time;
      var value = Math.max(rawValue, minInput);

      if (logInput) value = Math.log(value);

      var diff = value - this.lastMvavrg;
      this.lastMvavrg = this.movingAverage.inputScalar(value);

      // update frame metadata
      this.frame.metadata = frame.metadata;

      if (diff > threshold && time - this.onsetTime > minInter) {
        if (this.insideSegment) this.outputSegment(time);

        // start segment
        this.insideSegment = true;
        this.onsetTime = time;
        this.max = -Infinity;
      }

      if (this.insideSegment) {
        this.min = min(this.min, rawValue);
        this.max = max(this.max, rawValue);
        this.sum += rawValue;
        this.sumOfSquares += rawValue * rawValue;
        this.count++;

        if (time - this.onsetTime >= maxDuration || value <= offThreshold) {
          this.outputSegment(time);
          this.insideSegment = false;
        }
      }
    }
  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();
      this.processFunction(frame);
      // do not propagate here as the frameRate is now zero
    }
  }]);
  return Segmenter;
}(_BaseLfo3.default);

exports.default = Segmenter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNlZ21lbnRlci5qcyJdLCJuYW1lcyI6WyJtaW4iLCJNYXRoIiwibWF4IiwiZGVmaW5pdGlvbnMiLCJsb2dJbnB1dCIsInR5cGUiLCJkZWZhdWx0IiwibWV0YXMiLCJraW5kIiwibWluSW5wdXQiLCJmaWx0ZXJPcmRlciIsInRocmVzaG9sZCIsIm9mZlRocmVzaG9sZCIsIkluZmluaXR5IiwibWluSW50ZXIiLCJtYXhEdXJhdGlvbiIsIlNlZ21lbnRlciIsIm9wdGlvbnMiLCJpbnNpZGVTZWdtZW50Iiwib25zZXRUaW1lIiwic3VtIiwic3VtT2ZTcXVhcmVzIiwiY291bnQiLCJwYXJhbXMiLCJnZXQiLCJmaWxsIiwibG9nIiwibW92aW5nQXZlcmFnZSIsIm9yZGVyIiwibGFzdE12YXZyZyIsIm5hbWUiLCJ2YWx1ZSIsInNldCIsInByZXZTdHJlYW1QYXJhbXMiLCJwcmVwYXJlU3RyZWFtUGFyYW1zIiwic3RyZWFtUGFyYW1zIiwiZnJhbWVUeXBlIiwiZnJhbWVTaXplIiwiZnJhbWVSYXRlIiwiZGVzY3JpcHRpb24iLCJpbml0U3RyZWFtIiwicHJvcGFnYXRlU3RyZWFtUGFyYW1zIiwicmVzZXRTdHJlYW0iLCJyZXNldFNlZ21lbnQiLCJlbmRUaW1lIiwib3V0cHV0U2VnbWVudCIsIm91dERhdGEiLCJmcmFtZSIsImRhdGEiLCJub3JtIiwibWVhbiIsIm1lYW5PZlNxdWFyZSIsInNxdWFyZU9mbWVhbiIsInNxcnQiLCJ0aW1lIiwicHJvcGFnYXRlRnJhbWUiLCJyYXdWYWx1ZSIsImRpZmYiLCJpbnB1dFNjYWxhciIsIm1ldGFkYXRhIiwicHJlcGFyZUZyYW1lIiwicHJvY2Vzc0Z1bmN0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxNQUFNQyxLQUFLRCxHQUFqQjtBQUNBLElBQU1FLE1BQU1ELEtBQUtDLEdBQWpCOztBQUVBLElBQU1DLGNBQWM7QUFDbEJDLFlBQVU7QUFDUkMsVUFBTSxTQURFO0FBRVJDLGFBQVMsS0FGRDtBQUdSQyxXQUFPLEVBQUVDLE1BQU0sU0FBUjtBQUhDLEdBRFE7QUFNbEJDLFlBQVU7QUFDUkosVUFBTSxPQURFO0FBRVJDLGFBQVMsY0FGRDtBQUdSQyxXQUFPLEVBQUVDLE1BQU0sU0FBUjtBQUhDLEdBTlE7QUFXbEJFLGVBQWE7QUFDWEwsVUFBTSxTQURLO0FBRVhDLGFBQVMsQ0FGRTtBQUdYQyxXQUFPLEVBQUVDLE1BQU0sU0FBUjtBQUhJLEdBWEs7QUFnQmxCRyxhQUFXO0FBQ1ROLFVBQU0sT0FERztBQUVUQyxhQUFTLENBRkE7QUFHVEMsV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFIRSxHQWhCTztBQXFCbEJJLGdCQUFjO0FBQ1pQLFVBQU0sT0FETTtBQUVaQyxhQUFTLENBQUNPLFFBRkU7QUFHWk4sV0FBTyxFQUFFQyxNQUFNLFNBQVI7QUFISyxHQXJCSTtBQTBCbEJNLFlBQVU7QUFDUlQsVUFBTSxPQURFO0FBRVJDLGFBQVMsS0FGRDtBQUdSQyxXQUFPLEVBQUVDLE1BQU0sU0FBUjtBQUhDLEdBMUJRO0FBK0JsQk8sZUFBYTtBQUNYVixVQUFNLE9BREs7QUFFWEMsYUFBU08sUUFGRTtBQUdYTixXQUFPLEVBQUVDLE1BQU0sU0FBUjtBQUhJOztBQU9mOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF0Q29CLENBQXBCO0lBK0ZNUSxTOzs7QUFDSixxQkFBWUMsT0FBWixFQUFxQjtBQUFBOztBQUFBLDRJQUNiZCxXQURhLEVBQ0FjLE9BREE7O0FBR25CLFVBQUtDLGFBQUwsR0FBcUIsS0FBckI7QUFDQSxVQUFLQyxTQUFMLEdBQWlCLENBQUNOLFFBQWxCOztBQUVBO0FBQ0EsVUFBS2IsR0FBTCxHQUFXYSxRQUFYO0FBQ0EsVUFBS1gsR0FBTCxHQUFXLENBQUNXLFFBQVo7QUFDQSxVQUFLTyxHQUFMLEdBQVcsQ0FBWDtBQUNBLFVBQUtDLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQSxVQUFLQyxLQUFMLEdBQWEsQ0FBYjs7QUFFQSxRQUFNYixXQUFXLE1BQUtjLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixVQUFoQixDQUFqQjtBQUNBLFFBQUlDLE9BQU9oQixRQUFYOztBQUVBLFFBQUksTUFBS2MsTUFBTCxDQUFZQyxHQUFaLENBQWdCLFVBQWhCLEtBQStCZixXQUFXLENBQTlDLEVBQ0VnQixPQUFPeEIsS0FBS3lCLEdBQUwsQ0FBU2pCLFFBQVQsQ0FBUDs7QUFFRixVQUFLa0IsYUFBTCxHQUFxQiw0QkFBa0I7QUFDckNDLGFBQU8sTUFBS0wsTUFBTCxDQUFZQyxHQUFaLENBQWdCLGFBQWhCLENBRDhCO0FBRXJDQyxZQUFNQTtBQUYrQixLQUFsQixDQUFyQjs7QUFLQSxVQUFLSSxVQUFMLEdBQWtCSixJQUFsQjtBQXhCbUI7QUF5QnBCOzs7O2tDQUVhSyxJLEVBQU1DLEssRUFBT3hCLEssRUFBTztBQUNoQyxnSkFBb0J1QixJQUFwQixFQUEwQkMsS0FBMUIsRUFBaUN4QixLQUFqQzs7QUFFQSxVQUFJdUIsU0FBUyxhQUFiLEVBQ0UsS0FBS0gsYUFBTCxDQUFtQkosTUFBbkIsQ0FBMEJTLEdBQTFCLENBQThCLE9BQTlCLEVBQXVDRCxLQUF2QztBQUNIOzs7d0NBRW1CRSxnQixFQUFrQjtBQUNwQyxXQUFLQyxtQkFBTCxDQUF5QkQsZ0JBQXpCOztBQUVBLFdBQUtFLFlBQUwsQ0FBa0JDLFNBQWxCLEdBQThCLFFBQTlCO0FBQ0EsV0FBS0QsWUFBTCxDQUFrQkUsU0FBbEIsR0FBOEIsQ0FBOUI7QUFDQSxXQUFLRixZQUFMLENBQWtCRyxTQUFsQixHQUE4QixDQUE5QjtBQUNBLFdBQUtILFlBQUwsQ0FBa0JJLFdBQWxCLEdBQWdDLENBQUMsVUFBRCxFQUFhLEtBQWIsRUFBb0IsS0FBcEIsRUFBMkIsTUFBM0IsRUFBbUMsUUFBbkMsQ0FBaEM7O0FBR0EsV0FBS1osYUFBTCxDQUFtQmEsVUFBbkIsQ0FBOEJQLGdCQUE5Qjs7QUFFQSxXQUFLUSxxQkFBTDtBQUNEOzs7a0NBRWE7QUFDWjtBQUNBLFdBQUtkLGFBQUwsQ0FBbUJlLFdBQW5CO0FBQ0EsV0FBS0MsWUFBTDtBQUNEOzs7bUNBRWNDLE8sRUFBUztBQUN0QixVQUFJLEtBQUsxQixhQUFULEVBQ0UsS0FBSzJCLGFBQUwsQ0FBbUJELE9BQW5COztBQUVGLGlKQUFxQkEsT0FBckI7QUFDRDs7O21DQUVjO0FBQ2IsV0FBSzFCLGFBQUwsR0FBcUIsS0FBckI7QUFDQSxXQUFLQyxTQUFMLEdBQWlCLENBQUNOLFFBQWxCO0FBQ0E7QUFDQSxXQUFLYixHQUFMLEdBQVdhLFFBQVg7QUFDQSxXQUFLWCxHQUFMLEdBQVcsQ0FBQ1csUUFBWjtBQUNBLFdBQUtPLEdBQUwsR0FBVyxDQUFYO0FBQ0EsV0FBS0MsWUFBTCxHQUFvQixDQUFwQjtBQUNBLFdBQUtDLEtBQUwsR0FBYSxDQUFiO0FBQ0Q7OztrQ0FFYXNCLE8sRUFBUztBQUNyQixVQUFNRSxVQUFVLEtBQUtDLEtBQUwsQ0FBV0MsSUFBM0I7QUFDQUYsY0FBUSxDQUFSLElBQWFGLFVBQVUsS0FBS3pCLFNBQTVCO0FBQ0EyQixjQUFRLENBQVIsSUFBYSxLQUFLOUMsR0FBbEI7QUFDQThDLGNBQVEsQ0FBUixJQUFhLEtBQUs1QyxHQUFsQjs7QUFFQSxVQUFNK0MsT0FBTyxJQUFJLEtBQUszQixLQUF0QjtBQUNBLFVBQU00QixPQUFPLEtBQUs5QixHQUFMLEdBQVc2QixJQUF4QjtBQUNBLFVBQU1FLGVBQWUsS0FBSzlCLFlBQUwsR0FBb0I0QixJQUF6QztBQUNBLFVBQU1HLGVBQWVGLE9BQU9BLElBQTVCOztBQUVBSixjQUFRLENBQVIsSUFBYUksSUFBYjtBQUNBSixjQUFRLENBQVIsSUFBYSxDQUFiOztBQUVBLFVBQUlLLGVBQWVDLFlBQW5CLEVBQ0VOLFFBQVEsQ0FBUixJQUFhN0MsS0FBS29ELElBQUwsQ0FBVUYsZUFBZUMsWUFBekIsQ0FBYjs7QUFFRixXQUFLTCxLQUFMLENBQVdPLElBQVgsR0FBa0IsS0FBS25DLFNBQXZCOztBQUVBLFdBQUtvQyxjQUFMO0FBQ0Q7OztrQ0FFYVIsSyxFQUFPO0FBQ25CLFVBQU0zQyxXQUFXLEtBQUttQixNQUFMLENBQVlDLEdBQVosQ0FBZ0IsVUFBaEIsQ0FBakI7QUFDQSxVQUFNZixXQUFXLEtBQUtjLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixVQUFoQixDQUFqQjtBQUNBLFVBQU1iLFlBQVksS0FBS1ksTUFBTCxDQUFZQyxHQUFaLENBQWdCLFdBQWhCLENBQWxCO0FBQ0EsVUFBTVYsV0FBVyxLQUFLUyxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsVUFBaEIsQ0FBakI7QUFDQSxVQUFNVCxjQUFjLEtBQUtRLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixhQUFoQixDQUFwQjtBQUNBLFVBQU1aLGVBQWUsS0FBS1csTUFBTCxDQUFZQyxHQUFaLENBQWdCLGNBQWhCLENBQXJCO0FBQ0EsVUFBTWdDLFdBQVdULE1BQU1DLElBQU4sQ0FBVyxDQUFYLENBQWpCO0FBQ0EsVUFBTU0sT0FBT1AsTUFBTU8sSUFBbkI7QUFDQSxVQUFJdkIsUUFBUTlCLEtBQUtDLEdBQUwsQ0FBU3NELFFBQVQsRUFBbUIvQyxRQUFuQixDQUFaOztBQUVBLFVBQUlMLFFBQUosRUFDRTJCLFFBQVE5QixLQUFLeUIsR0FBTCxDQUFTSyxLQUFULENBQVI7O0FBRUYsVUFBTTBCLE9BQU8xQixRQUFRLEtBQUtGLFVBQTFCO0FBQ0EsV0FBS0EsVUFBTCxHQUFrQixLQUFLRixhQUFMLENBQW1CK0IsV0FBbkIsQ0FBK0IzQixLQUEvQixDQUFsQjs7QUFFQTtBQUNBLFdBQUtnQixLQUFMLENBQVdZLFFBQVgsR0FBc0JaLE1BQU1ZLFFBQTVCOztBQUVBLFVBQUlGLE9BQU85QyxTQUFQLElBQW9CMkMsT0FBTyxLQUFLbkMsU0FBWixHQUF3QkwsUUFBaEQsRUFBMEQ7QUFDeEQsWUFBSSxLQUFLSSxhQUFULEVBQ0UsS0FBSzJCLGFBQUwsQ0FBbUJTLElBQW5COztBQUVGO0FBQ0EsYUFBS3BDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCbUMsSUFBakI7QUFDQSxhQUFLcEQsR0FBTCxHQUFXLENBQUNXLFFBQVo7QUFDRDs7QUFFRCxVQUFJLEtBQUtLLGFBQVQsRUFBd0I7QUFDdEIsYUFBS2xCLEdBQUwsR0FBV0EsSUFBSSxLQUFLQSxHQUFULEVBQWN3RCxRQUFkLENBQVg7QUFDQSxhQUFLdEQsR0FBTCxHQUFXQSxJQUFJLEtBQUtBLEdBQVQsRUFBY3NELFFBQWQsQ0FBWDtBQUNBLGFBQUtwQyxHQUFMLElBQVlvQyxRQUFaO0FBQ0EsYUFBS25DLFlBQUwsSUFBcUJtQyxXQUFXQSxRQUFoQztBQUNBLGFBQUtsQyxLQUFMOztBQUVBLFlBQUlnQyxPQUFPLEtBQUtuQyxTQUFaLElBQXlCSixXQUF6QixJQUF3Q2dCLFNBQVNuQixZQUFyRCxFQUFtRTtBQUNqRSxlQUFLaUMsYUFBTCxDQUFtQlMsSUFBbkI7QUFDQSxlQUFLcEMsYUFBTCxHQUFxQixLQUFyQjtBQUNEO0FBQ0Y7QUFDRjs7O2lDQUVZNkIsSyxFQUFPO0FBQ2xCLFdBQUthLFlBQUw7QUFDQSxXQUFLQyxlQUFMLENBQXFCZCxLQUFyQjtBQUNBO0FBQ0Q7Ozs7O2tCQUdZL0IsUyIsImZpbGUiOiJTZWdtZW50ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuaW1wb3J0IE1vdmluZ0F2ZXJhZ2UgZnJvbSAnLi9Nb3ZpbmdBdmVyYWdlJztcblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIGxvZ0lucHV0OiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxuICBtaW5JbnB1dDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMC4wMDAwMDAwMDAwMDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIGZpbHRlck9yZGVyOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIHRocmVzaG9sZDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMyxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgb2ZmVGhyZXNob2xkOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAtSW5maW5pdHksXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIG1pbkludGVyOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLjA1MCxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgbWF4RHVyYXRpb246IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IEluZmluaXR5LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxufVxuXG4vKipcbiAqIENyZWF0ZSBzZWdtZW50cyBiYXNlZCBvbiBhdHRhY2tzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmxvZ0lucHV0PWZhbHNlXSAtIEFwcGx5IGxvZyBvbiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluSW5wdXQ9MC4wMDAwMDAwMDAwMDFdIC0gTWluaW11bSB2YWx1ZSB0byB1c2UgYXNcbiAqICBpbnB1dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5maWx0ZXJPcmRlcj01XSAtIE9yZGVyIG9mIHRoZSBpbnRlcm5hbGx5IHVzZWQgbW92aW5nXG4gKiAgYXZlcmFnZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9M10gLSBUaHJlc2hvbGQgdGhhdCB0cmlnZ2VycyBhIHNlZ21lbnRcbiAqICBzdGFydC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZUaHJlc2hvbGQ9LUluZmluaXR5XSAtIFRocmVzaG9sZCB0aGF0IHRyaWdnZXJzXG4gKiAgYSBzZWdtZW50IGVuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5JbnRlcj0wLjA1MF0gLSBNaW5pbXVtIGRlbGF5IGJldHdlZW4gdHdvIHNlbWdlbnRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heER1cmF0aW9uPUluZmluaXR5XSAtIE1heGltdW0gZHVyYXRpb24gb2YgYSBzZWdtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogLy8gYXNzdW1pbmcgYSBzdHJlYW0gZnJvbSB0aGUgbWljcm9waG9uZVxuICogY29uc3Qgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG4gKlxuICogY29uc3QgYXVkaW9Jbk5vZGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luTm9kZSh7XG4gKiAgIHNvdXJjZU5vZGU6IHNvdXJjZSxcbiAqICAgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBzbGljZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogZnJhbWVTaXplLFxuICogICBob3BTaXplOiBob3BTaXplLFxuICogICBjZW50ZXJlZFRpbWVUYWdzOiB0cnVlXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBwb3dlciA9IG5ldyBsZm8ub3BlcmF0b3IuUk1TKHtcbiAqICAgcG93ZXI6IHRydWUsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBzZWdtZW50ZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNlZ21lbnRlcih7XG4gKiAgIGxvZ0lucHV0OiB0cnVlLFxuICogICBmaWx0ZXJPcmRlcjogNSxcbiAqICAgdGhyZXNob2xkOiAzLFxuICogICBvZmZUaHJlc2hvbGQ6IC1JbmZpbml0eSxcbiAqICAgbWluSW50ZXI6IDAuMDUwLFxuICogICBtYXhEdXJhdGlvbjogMC4wNTAsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgdGltZTogdHJ1ZSB9KTtcbiAqXG4gKiBhdWRpb0luTm9kZS5jb25uZWN0KHNsaWNlcik7XG4gKiBzbGljZXIuY29ubmVjdChwb3dlcik7XG4gKiBwb3dlci5jb25uZWN0KHNlZ21lbnRlcik7XG4gKiBzZWdtZW50ZXIuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKi9cbmNsYXNzIFNlZ21lbnRlciBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbnNpZGVTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5vbnNldFRpbWUgPSAtSW5maW5pdHk7XG5cbiAgICAvLyBzdGF0c1xuICAgIHRoaXMubWluID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXggPSAtSW5maW5pdHk7XG4gICAgdGhpcy5zdW0gPSAwO1xuICAgIHRoaXMuc3VtT2ZTcXVhcmVzID0gMDtcbiAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgIGNvbnN0IG1pbklucHV0ID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW5JbnB1dCcpO1xuICAgIGxldCBmaWxsID0gbWluSW5wdXQ7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCdsb2dJbnB1dCcpICYmIG1pbklucHV0ID4gMClcbiAgICAgIGZpbGwgPSBNYXRoLmxvZyhtaW5JbnB1dCk7XG5cbiAgICB0aGlzLm1vdmluZ0F2ZXJhZ2UgPSBuZXcgTW92aW5nQXZlcmFnZSh7XG4gICAgICBvcmRlcjogdGhpcy5wYXJhbXMuZ2V0KCdmaWx0ZXJPcmRlcicpLFxuICAgICAgZmlsbDogZmlsbCxcbiAgICB9KTtcblxuICAgIHRoaXMubGFzdE12YXZyZyA9IGZpbGw7XG4gIH1cblxuICBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIGlmIChuYW1lID09PSAnZmlsdGVyT3JkZXInKVxuICAgICAgdGhpcy5tb3ZpbmdBdmVyYWdlLnBhcmFtcy5zZXQoJ29yZGVyJywgdmFsdWUpO1xuICB9XG5cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gNTtcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSAwO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gWydkdXJhdGlvbicsICdtaW4nLCAnbWF4JywgJ21lYW4nLCAnc3RkZGV2J107XG5cblxuICAgIHRoaXMubW92aW5nQXZlcmFnZS5pbml0U3RyZWFtKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIHJlc2V0U3RyZWFtKCkge1xuICAgIHN1cGVyLnJlc2V0U3RyZWFtKCk7XG4gICAgdGhpcy5tb3ZpbmdBdmVyYWdlLnJlc2V0U3RyZWFtKCk7XG4gICAgdGhpcy5yZXNldFNlZ21lbnQoKTtcbiAgfVxuXG4gIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICBpZiAodGhpcy5pbnNpZGVTZWdtZW50KVxuICAgICAgdGhpcy5vdXRwdXRTZWdtZW50KGVuZFRpbWUpO1xuXG4gICAgc3VwZXIuZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG4gIH1cblxuICByZXNldFNlZ21lbnQoKSB7XG4gICAgdGhpcy5pbnNpZGVTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5vbnNldFRpbWUgPSAtSW5maW5pdHk7XG4gICAgLy8gc3RhdHNcbiAgICB0aGlzLm1pbiA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4ID0gLUluZmluaXR5O1xuICAgIHRoaXMuc3VtID0gMDtcbiAgICB0aGlzLnN1bU9mU3F1YXJlcyA9IDA7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICBvdXRwdXRTZWdtZW50KGVuZFRpbWUpIHtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIG91dERhdGFbMF0gPSBlbmRUaW1lIC0gdGhpcy5vbnNldFRpbWU7XG4gICAgb3V0RGF0YVsxXSA9IHRoaXMubWluO1xuICAgIG91dERhdGFbMl0gPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IG5vcm0gPSAxIC8gdGhpcy5jb3VudDtcbiAgICBjb25zdCBtZWFuID0gdGhpcy5zdW0gKiBub3JtO1xuICAgIGNvbnN0IG1lYW5PZlNxdWFyZSA9IHRoaXMuc3VtT2ZTcXVhcmVzICogbm9ybTtcbiAgICBjb25zdCBzcXVhcmVPZm1lYW4gPSBtZWFuICogbWVhbjtcblxuICAgIG91dERhdGFbM10gPSBtZWFuO1xuICAgIG91dERhdGFbNF0gPSAwO1xuXG4gICAgaWYgKG1lYW5PZlNxdWFyZSA+IHNxdWFyZU9mbWVhbilcbiAgICAgIG91dERhdGFbNF0gPSBNYXRoLnNxcnQobWVhbk9mU3F1YXJlIC0gc3F1YXJlT2ZtZWFuKTtcblxuICAgIHRoaXMuZnJhbWUudGltZSA9IHRoaXMub25zZXRUaW1lO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICB9XG5cbiAgcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgIGNvbnN0IGxvZ0lucHV0ID0gdGhpcy5wYXJhbXMuZ2V0KCdsb2dJbnB1dCcpO1xuICAgIGNvbnN0IG1pbklucHV0ID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW5JbnB1dCcpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMucGFyYW1zLmdldCgndGhyZXNob2xkJyk7XG4gICAgY29uc3QgbWluSW50ZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ21pbkludGVyJyk7XG4gICAgY29uc3QgbWF4RHVyYXRpb24gPSB0aGlzLnBhcmFtcy5nZXQoJ21heER1cmF0aW9uJyk7XG4gICAgY29uc3Qgb2ZmVGhyZXNob2xkID0gdGhpcy5wYXJhbXMuZ2V0KCdvZmZUaHJlc2hvbGQnKTtcbiAgICBjb25zdCByYXdWYWx1ZSA9IGZyYW1lLmRhdGFbMF07XG4gICAgY29uc3QgdGltZSA9IGZyYW1lLnRpbWU7XG4gICAgbGV0IHZhbHVlID0gTWF0aC5tYXgocmF3VmFsdWUsIG1pbklucHV0KTtcblxuICAgIGlmIChsb2dJbnB1dClcbiAgICAgIHZhbHVlID0gTWF0aC5sb2codmFsdWUpO1xuXG4gICAgY29uc3QgZGlmZiA9IHZhbHVlIC0gdGhpcy5sYXN0TXZhdnJnO1xuICAgIHRoaXMubGFzdE12YXZyZyA9IHRoaXMubW92aW5nQXZlcmFnZS5pbnB1dFNjYWxhcih2YWx1ZSk7XG5cbiAgICAvLyB1cGRhdGUgZnJhbWUgbWV0YWRhdGFcbiAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG5cbiAgICBpZiAoZGlmZiA+IHRocmVzaG9sZCAmJiB0aW1lIC0gdGhpcy5vbnNldFRpbWUgPiBtaW5JbnRlcikge1xuICAgICAgaWYgKHRoaXMuaW5zaWRlU2VnbWVudClcbiAgICAgICAgdGhpcy5vdXRwdXRTZWdtZW50KHRpbWUpO1xuXG4gICAgICAvLyBzdGFydCBzZWdtZW50XG4gICAgICB0aGlzLmluc2lkZVNlZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy5vbnNldFRpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5tYXggPSAtSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5zaWRlU2VnbWVudCkge1xuICAgICAgdGhpcy5taW4gPSBtaW4odGhpcy5taW4sIHJhd1ZhbHVlKTtcbiAgICAgIHRoaXMubWF4ID0gbWF4KHRoaXMubWF4LCByYXdWYWx1ZSk7XG4gICAgICB0aGlzLnN1bSArPSByYXdWYWx1ZTtcbiAgICAgIHRoaXMuc3VtT2ZTcXVhcmVzICs9IHJhd1ZhbHVlICogcmF3VmFsdWU7XG4gICAgICB0aGlzLmNvdW50Kys7XG5cbiAgICAgIGlmICh0aW1lIC0gdGhpcy5vbnNldFRpbWUgPj0gbWF4RHVyYXRpb24gfHwgdmFsdWUgPD0gb2ZmVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2VnbWVudCh0aW1lKTtcbiAgICAgICAgdGhpcy5pbnNpZGVTZWdtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbihmcmFtZSk7XG4gICAgLy8gZG8gbm90IHByb3BhZ2F0ZSBoZXJlIGFzIHRoZSBmcmFtZVJhdGUgaXMgbm93IHplcm9cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50ZXI7XG4iXX0=