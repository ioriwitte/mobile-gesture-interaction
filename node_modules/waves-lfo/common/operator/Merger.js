'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  // array defining the frameSizes of the input streamss
  // e.g. if [3, 2, 1], we wait for 3 different sources of respective 3, 2, 1 frameSizes
  frameSizes: {
    type: 'any',
    default: null,
    constant: true
  }

  /**
   * Merge multiple vector frames. The order of execution depends on the
   * order the branching was initially made. The first branche is master
   * on the time and trigger the output of the frame.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters
   * @param {Array} [options.frameSizes=null] - Array that defines the number
   *  of values to pick from each incomming vectors.
   *
   * @example
   * import * as lfo from 'waves-lfo/comon'
   *
   * const eventIn = new lfo.operator.EventIn({
   *   type: 'vector',
   *   frameSize: 4,
   *   frameRate: 0,
   * });
   *
   * const minMax = new lfo.operator.MinMax();
   * const magnitude = new lfo.operator.Magnitude();
   *
   * // take the first 2 values of the first branch and 1 value from the second branch
   * const merge = new lfo.operator.Merger({ frameSizes: [2, 1] });
   *
   * // this defines the order in which Merger will be called
   * eventIn.connect(minMax);
   * eventIn.connect(magnitude);
   *
   * minMax.connect(merger);
   * magnitude.connect(merger);
   */
};
var Merger = function (_BaseLfo) {
  (0, _inherits3.default)(Merger, _BaseLfo);

  function Merger(options) {
    (0, _classCallCheck3.default)(this, Merger);
    return (0, _possibleConstructorReturn3.default)(this, (Merger.__proto__ || (0, _getPrototypeOf2.default)(Merger)).call(this, definitions, options));
  }

  (0, _createClass3.default)(Merger, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      // ...
      var frameSizes = this.params.get('frameSizes');
      var numSources = frameSizes.length;

      var frameSize = 0;
      for (var i = 0; i < numSources; i++) {
        frameSize += frameSizes[i];
      }this.streamParams.frameSize = frameSize;
      this.numSources = numSources;
      this.sourceIndex = 0;

      this.propagateStreamParams();
    }
  }, {
    key: 'processVector',
    value: function processVector() {}
    // processSignal() {} // makes no sens to merge signals (maybe MUX / DEMUX)

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      var currentIndex = this.sourceIndex;
      var frameSizes = this.params.get('frameSizes');
      var numSources = frameSizes.length;
      var input = frame.data;
      var output = this.frame.data;

      // first source define time
      if (currentIndex === 0) this.frame.time = frame.time;

      var currentFrameSize = frameSizes[currentIndex];
      var offset = 0;

      for (var i = 0; i < currentIndex; i++) {
        offset += frameSizes[i];
      } // copy data
      for (var _i = 0; _i < currentFrameSize; _i++) {
        output[offset + _i] = input[_i];
      }this.sourceIndex = (this.sourceIndex + 1) % numSources;

      // we just received the last input, output the frame
      if (this.sourceIndex === 0) this.propagateFrame();
    }
  }]);
  return Merger;
}(_BaseLfo3.default);

exports.default = Merger;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1lcmdlci5qcyJdLCJuYW1lcyI6WyJkZWZpbml0aW9ucyIsImZyYW1lU2l6ZXMiLCJ0eXBlIiwiZGVmYXVsdCIsImNvbnN0YW50IiwiTWVyZ2VyIiwib3B0aW9ucyIsInByZXZTdHJlYW1QYXJhbXMiLCJwcmVwYXJlU3RyZWFtUGFyYW1zIiwicGFyYW1zIiwiZ2V0IiwibnVtU291cmNlcyIsImxlbmd0aCIsImZyYW1lU2l6ZSIsImkiLCJzdHJlYW1QYXJhbXMiLCJzb3VyY2VJbmRleCIsInByb3BhZ2F0ZVN0cmVhbVBhcmFtcyIsImZyYW1lIiwiY3VycmVudEluZGV4IiwiaW5wdXQiLCJkYXRhIiwib3V0cHV0IiwidGltZSIsImN1cnJlbnRGcmFtZVNpemUiLCJvZmZzZXQiLCJwcm9wYWdhdGVGcmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0FBRUEsSUFBTUEsY0FBYztBQUNsQjtBQUNBO0FBQ0FDLGNBQVk7QUFDVkMsVUFBTSxLQURJO0FBRVZDLGFBQVMsSUFGQztBQUdWQyxjQUFVO0FBSEE7O0FBT2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVZvQixDQUFwQjtJQTJDTUMsTTs7O0FBQ0osa0JBQVlDLE9BQVosRUFBcUI7QUFBQTtBQUFBLGlJQUNiTixXQURhLEVBQ0FNLE9BREE7QUFFcEI7Ozs7d0NBRW1CQyxnQixFQUFrQjtBQUNwQyxXQUFLQyxtQkFBTCxDQUF5QkQsZ0JBQXpCOztBQUVBO0FBQ0EsVUFBTU4sYUFBYSxLQUFLUSxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsWUFBaEIsQ0FBbkI7QUFDQSxVQUFNQyxhQUFhVixXQUFXVyxNQUE5Qjs7QUFFQSxVQUFJQyxZQUFZLENBQWhCO0FBQ0EsV0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILFVBQXBCLEVBQWdDRyxHQUFoQztBQUNFRCxxQkFBYVosV0FBV2EsQ0FBWCxDQUFiO0FBREYsT0FJQSxLQUFLQyxZQUFMLENBQWtCRixTQUFsQixHQUE4QkEsU0FBOUI7QUFDQSxXQUFLRixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFdBQUtLLFdBQUwsR0FBbUIsQ0FBbkI7O0FBRUEsV0FBS0MscUJBQUw7QUFDRDs7O29DQUVlLENBQUU7QUFDbEI7Ozs7aUNBRWFDLEssRUFBTztBQUNsQixVQUFNQyxlQUFlLEtBQUtILFdBQTFCO0FBQ0EsVUFBTWYsYUFBYSxLQUFLUSxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsWUFBaEIsQ0FBbkI7QUFDQSxVQUFNQyxhQUFhVixXQUFXVyxNQUE5QjtBQUNBLFVBQU1RLFFBQVFGLE1BQU1HLElBQXBCO0FBQ0EsVUFBTUMsU0FBUyxLQUFLSixLQUFMLENBQVdHLElBQTFCOztBQUVBO0FBQ0EsVUFBSUYsaUJBQWlCLENBQXJCLEVBQ0UsS0FBS0QsS0FBTCxDQUFXSyxJQUFYLEdBQWtCTCxNQUFNSyxJQUF4Qjs7QUFFRixVQUFNQyxtQkFBbUJ2QixXQUFXa0IsWUFBWCxDQUF6QjtBQUNBLFVBQUlNLFNBQVMsQ0FBYjs7QUFFQSxXQUFLLElBQUlYLElBQUksQ0FBYixFQUFnQkEsSUFBSUssWUFBcEIsRUFBa0NMLEdBQWxDO0FBQ0VXLGtCQUFVeEIsV0FBV2EsQ0FBWCxDQUFWO0FBREYsT0Fka0IsQ0FpQmxCO0FBQ0EsV0FBSyxJQUFJQSxLQUFJLENBQWIsRUFBZ0JBLEtBQUlVLGdCQUFwQixFQUFzQ1YsSUFBdEM7QUFDRVEsZUFBT0csU0FBU1gsRUFBaEIsSUFBcUJNLE1BQU1OLEVBQU4sQ0FBckI7QUFERixPQUdBLEtBQUtFLFdBQUwsR0FBbUIsQ0FBQyxLQUFLQSxXQUFMLEdBQW1CLENBQXBCLElBQXlCTCxVQUE1Qzs7QUFFQTtBQUNBLFVBQUksS0FBS0ssV0FBTCxLQUFxQixDQUF6QixFQUNFLEtBQUtVLGNBQUw7QUFDSDs7Ozs7a0JBR1lyQixNIiwiZmlsZSI6Ik1lcmdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICAvLyBhcnJheSBkZWZpbmluZyB0aGUgZnJhbWVTaXplcyBvZiB0aGUgaW5wdXQgc3RyZWFtc3NcbiAgLy8gZS5nLiBpZiBbMywgMiwgMV0sIHdlIHdhaXQgZm9yIDMgZGlmZmVyZW50IHNvdXJjZXMgb2YgcmVzcGVjdGl2ZSAzLCAyLCAxIGZyYW1lU2l6ZXNcbiAgZnJhbWVTaXplczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSB2ZWN0b3IgZnJhbWVzLiBUaGUgb3JkZXIgb2YgZXhlY3V0aW9uIGRlcGVuZHMgb24gdGhlXG4gKiBvcmRlciB0aGUgYnJhbmNoaW5nIHdhcyBpbml0aWFsbHkgbWFkZS4gVGhlIGZpcnN0IGJyYW5jaGUgaXMgbWFzdGVyXG4gKiBvbiB0aGUgdGltZSBhbmQgdHJpZ2dlciB0aGUgb3V0cHV0IG9mIHRoZSBmcmFtZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mcmFtZVNpemVzPW51bGxdIC0gQXJyYXkgdGhhdCBkZWZpbmVzIHRoZSBudW1iZXJcbiAqICBvZiB2YWx1ZXMgdG8gcGljayBmcm9tIGVhY2ggaW5jb21taW5nIHZlY3RvcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tb24nXG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8ub3BlcmF0b3IuRXZlbnRJbih7XG4gKiAgIHR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDQsXG4gKiAgIGZyYW1lUmF0ZTogMCxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1pbk1heCA9IG5ldyBsZm8ub3BlcmF0b3IuTWluTWF4KCk7XG4gKiBjb25zdCBtYWduaXR1ZGUgPSBuZXcgbGZvLm9wZXJhdG9yLk1hZ25pdHVkZSgpO1xuICpcbiAqIC8vIHRha2UgdGhlIGZpcnN0IDIgdmFsdWVzIG9mIHRoZSBmaXJzdCBicmFuY2ggYW5kIDEgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIGJyYW5jaFxuICogY29uc3QgbWVyZ2UgPSBuZXcgbGZvLm9wZXJhdG9yLk1lcmdlcih7IGZyYW1lU2l6ZXM6IFsyLCAxXSB9KTtcbiAqXG4gKiAvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyIGluIHdoaWNoIE1lcmdlciB3aWxsIGJlIGNhbGxlZFxuICogZXZlbnRJbi5jb25uZWN0KG1pbk1heCk7XG4gKiBldmVudEluLmNvbm5lY3QobWFnbml0dWRlKTtcbiAqXG4gKiBtaW5NYXguY29ubmVjdChtZXJnZXIpO1xuICogbWFnbml0dWRlLmNvbm5lY3QobWVyZ2VyKTtcbiAqL1xuY2xhc3MgTWVyZ2VyIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAvLyAuLi5cbiAgICBjb25zdCBmcmFtZVNpemVzID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVNpemVzJyk7XG4gICAgY29uc3QgbnVtU291cmNlcyA9IGZyYW1lU2l6ZXMubGVuZ3RoO1xuXG4gICAgbGV0IGZyYW1lU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspXG4gICAgICBmcmFtZVNpemUgKz0gZnJhbWVTaXplc1tpXTtcblxuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVTaXplO1xuICAgIHRoaXMubnVtU291cmNlcyA9IG51bVNvdXJjZXM7XG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgcHJvY2Vzc1ZlY3RvcigpIHt9XG4gIC8vIHByb2Nlc3NTaWduYWwoKSB7fSAvLyBtYWtlcyBubyBzZW5zIHRvIG1lcmdlIHNpZ25hbHMgKG1heWJlIE1VWCAvIERFTVVYKVxuXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuc291cmNlSW5kZXg7XG4gICAgY29uc3QgZnJhbWVTaXplcyA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplcycpO1xuICAgIGNvbnN0IG51bVNvdXJjZXMgPSBmcmFtZVNpemVzLmxlbmd0aDtcbiAgICBjb25zdCBpbnB1dCA9IGZyYW1lLmRhdGE7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuXG4gICAgLy8gZmlyc3Qgc291cmNlIGRlZmluZSB0aW1lXG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMClcbiAgICAgIHRoaXMuZnJhbWUudGltZSA9IGZyYW1lLnRpbWU7XG5cbiAgICBjb25zdCBjdXJyZW50RnJhbWVTaXplID0gZnJhbWVTaXplc1tjdXJyZW50SW5kZXhdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50SW5kZXg7IGkrKylcbiAgICAgIG9mZnNldCArPSBmcmFtZVNpemVzW2ldO1xuXG4gICAgLy8gY29weSBkYXRhXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50RnJhbWVTaXplOyBpKyspXG4gICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBpbnB1dFtpXTtcblxuICAgIHRoaXMuc291cmNlSW5kZXggPSAodGhpcy5zb3VyY2VJbmRleCArIDEpICUgbnVtU291cmNlcztcblxuICAgIC8vIHdlIGp1c3QgcmVjZWl2ZWQgdGhlIGxhc3QgaW5wdXQsIG91dHB1dCB0aGUgZnJhbWVcbiAgICBpZiAodGhpcy5zb3VyY2VJbmRleCA9PT0gMClcbiAgICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXJnZXI7XG4iXX0=