'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function simpleLinearRegression(values, dt) {
  // means
  var xSum = 0;
  var ySum = 0;
  var length = values.length;

  for (var i = 0; i < length; i++) {
    xSum += i * dt;
    ySum += values[i];
  }

  var xMean = xSum / length;
  var yMean = ySum / length;

  var sumDiffXMeanSquared = 0; // sum[ pow((x - xMean), 2) ]
  var sumDiffYMeanSquared = 0; // sum[ pow((y - yMean), 2) ]
  var sumDiffXYMean = 0; // sum[ (x - xMean)(y - yMean) ]

  for (var _i = 0; _i < length; _i++) {
    var diffXMean = dt * _i - xMean;
    var diffYMean = values[_i] - yMean;

    var diffXMeanSquared = diffXMean * diffXMean;
    var diffYMeanSquared = diffYMean * diffYMean;
    var diffXYMean = diffXMean * diffYMean;

    sumDiffXMeanSquared += diffXMeanSquared;
    sumDiffYMeanSquared += diffYMeanSquared;
    sumDiffXYMean += diffXYMean;
  }

  // horizontal line, all y on same line
  if (sumDiffYMeanSquared === 0) return 0;

  // Pearson correlation coefficient:
  // cf. https://www.youtube.com/watch?v=2SCg8Kuh0tE
  //
  //                 ∑ [ (x - xMean)(y - yMean) ]
  // r = ------------------------------------------------------
  //     sqrt( ∑ [ pow((x - xMean), 2), pow((y - yMean), 2) ] )
  //
  //
  var r = sumDiffXYMean / Math.sqrt(sumDiffXMeanSquared * sumDiffYMeanSquared);

  // then we have:
  // cf. https://www.youtube.com/watch?v=GhrxgbQnEEU
  //
  // y = a + bx
  // where:
  //         Sy
  // b = r * --
  //         Sx
  //
  // a = yMean - b * xMean
  //
  // S for standard deviation
  //            ∑ [ pow((x - xMean), 2) ]
  // Sx = sqrt( -------------------------  )
  //                      N - 1
  var Sx = Math.sqrt(sumDiffXMeanSquared / (length - 1));
  var Sy = Math.sqrt(sumDiffYMeanSquared / (length - 1));
  var b = r * (Sy / Sx);

  return b;
}

var definitions = {
  size: {
    type: 'integer',
    min: 2,
    max: +Infinity,
    default: 3
  },
  useFrameRate: {
    type: 'integer',
    min: 0,
    max: +Infinity,
    default: null,
    nullable: true
  }
};

/**
 * Returns the simple derivative of successive value using
 * simple linear regression.
 * The current implementation assumes a fixed `frameRate` (`frame.time` is ignored)
 *
 * Before the module is filled, it outputs a value of 0.
 *
 * @param {Object} options - Override default parameters
 * @param {Number} [options.size=3] - Size of the window
 * @param {Number} [options.useFrameRate=null] - Override stream frame rate for
 *  the regression
 */

var Delta = function (_BaseLfo) {
  (0, _inherits3.default)(Delta, _BaseLfo);

  function Delta() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Delta);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Delta.__proto__ || (0, _getPrototypeOf2.default)(Delta)).call(this, definitions, options));

    _this.buffers = null;
    _this.ringIndex = 0;
    _this.frameRate = null;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Delta, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var frameSize = this.streamParams.frameSize;
      var size = this.params.get('size');
      var bufferSize = frameSize * size;

      this.buffers = [];
      // counter before the operator starts outputing frames
      this.ringIndex = 0;
      this.frameRate = this.params.get('useFrameRate') === null ? this.streamParams.frameRate : this.params.get('useFrameRate');

      for (var i = 0; i < frameSize; i++) {
        this.buffers[i] = new Float32Array(size);
      }this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(Delta.prototype.__proto__ || (0, _getPrototypeOf2.default)(Delta.prototype), 'resetStream', this).call(this);

      var frameSize = this.streamParams.frameSize;
      var size = this.params.get('size');
      var buffers = this.buffers;

      for (var i = 0; i < frameSize; i++) {
        for (var j = 0; j < size; j++) {
          buffers[i][j] = 0;
        }
      }

      this.ringIndex = 0;
    }

    /**
     * Assume a stream of vector at a fixed `frameRate`.
     */

  }, {
    key: 'inputVector',
    value: function inputVector(data) {
      var size = this.params.get('size');
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      // const frameRate = this.streamParams.frameRate;
      var buffers = this.buffers;
      var dt = 1 / this.frameRate;

      // console.log(dt);

      if (this.ringIndex < size) this.ringIndex += 1;

      // copy incomming data into buffer
      for (var i = 0; i < frameSize; i++) {
        var buffer = buffers[i];

        // we need to keep the order of the incomming frames
        // so we have to shift all the values in the buffers
        for (var j = 1; j < size; j++) {
          buffer[j - 1] = buffer[j];
        }buffer[size - 1] = data[i];

        if (this.ringIndex >= size) outData[i] = simpleLinearRegression(buffer, dt);else outData[i] = 0;
      }

      return outData;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
      // center time according to delta size
      var size = this.params.get('size');
      var frameRate = this.streamParams.frameRate;
      this.frame.time -= 0.5 * (size - 1) / frameRate;
    }
  }]);
  return Delta;
}(_BaseLfo3.default);

exports.default = Delta;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkRlbHRhLmpzIl0sIm5hbWVzIjpbInNpbXBsZUxpbmVhclJlZ3Jlc3Npb24iLCJ2YWx1ZXMiLCJkdCIsInhTdW0iLCJ5U3VtIiwibGVuZ3RoIiwiaSIsInhNZWFuIiwieU1lYW4iLCJzdW1EaWZmWE1lYW5TcXVhcmVkIiwic3VtRGlmZllNZWFuU3F1YXJlZCIsInN1bURpZmZYWU1lYW4iLCJkaWZmWE1lYW4iLCJkaWZmWU1lYW4iLCJkaWZmWE1lYW5TcXVhcmVkIiwiZGlmZllNZWFuU3F1YXJlZCIsImRpZmZYWU1lYW4iLCJyIiwiTWF0aCIsInNxcnQiLCJTeCIsIlN5IiwiYiIsImRlZmluaXRpb25zIiwic2l6ZSIsInR5cGUiLCJtaW4iLCJtYXgiLCJJbmZpbml0eSIsImRlZmF1bHQiLCJ1c2VGcmFtZVJhdGUiLCJudWxsYWJsZSIsIkRlbHRhIiwib3B0aW9ucyIsImJ1ZmZlcnMiLCJyaW5nSW5kZXgiLCJmcmFtZVJhdGUiLCJwcmV2U3RyZWFtUGFyYW1zIiwicHJlcGFyZVN0cmVhbVBhcmFtcyIsImZyYW1lU2l6ZSIsInN0cmVhbVBhcmFtcyIsInBhcmFtcyIsImdldCIsImJ1ZmZlclNpemUiLCJGbG9hdDMyQXJyYXkiLCJwcm9wYWdhdGVTdHJlYW1QYXJhbXMiLCJqIiwiZGF0YSIsIm91dERhdGEiLCJmcmFtZSIsImJ1ZmZlciIsImlucHV0VmVjdG9yIiwidGltZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztBQUdBLFNBQVNBLHNCQUFULENBQWdDQyxNQUFoQyxFQUF3Q0MsRUFBeEMsRUFBNEM7QUFDMUM7QUFDQSxNQUFJQyxPQUFPLENBQVg7QUFDQSxNQUFJQyxPQUFPLENBQVg7QUFDQSxNQUFNQyxTQUFTSixPQUFPSSxNQUF0Qjs7QUFFQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsTUFBcEIsRUFBNEJDLEdBQTVCLEVBQWlDO0FBQy9CSCxZQUFRRyxJQUFJSixFQUFaO0FBQ0FF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cEIsRUFBMEJzQixHQUExQjtBQUNFSSxpQkFBT0osSUFBSSxDQUFYLElBQWdCSSxPQUFPSixDQUFQLENBQWhCO0FBREYsU0FHQUksT0FBTzFCLE9BQU8sQ0FBZCxJQUFtQnVCLEtBQUt6QyxDQUFMLENBQW5COztBQUVBLFlBQUksS0FBSzZCLFNBQUwsSUFBa0JYLElBQXRCLEVBQ0V3QixRQUFRMUMsQ0FBUixJQUFhTix1QkFBdUJrRCxNQUF2QixFQUErQmhELEVBQS9CLENBQWIsQ0FERixLQUdFOEMsUUFBUTFDLENBQVIsSUFBYSxDQUFiO0FBQ0g7O0FBRUQsYUFBTzBDLE9BQVA7QUFDRDs7QUFFRDs7OztrQ0FDY0MsSyxFQUFPO0FBQ25CLFdBQUtBLEtBQUwsQ0FBV0YsSUFBWCxHQUFrQixLQUFLSSxXQUFMLENBQWlCRixNQUFNRixJQUF2QixDQUFsQjtBQUNBO0FBQ0EsVUFBTXZCLE9BQU8sS0FBS2lCLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixNQUFoQixDQUFiO0FBQ0EsVUFBTU4sWUFBWSxLQUFLSSxZQUFMLENBQWtCSixTQUFwQztBQUNBLFdBQUthLEtBQUwsQ0FBV0csSUFBWCxJQUFtQixPQUFPNUIsT0FBTyxDQUFkLElBQW1CWSxTQUF0QztBQUNEOzs7OztrQkFHWUosSyIsImZpbGUiOiJEZWx0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cblxuZnVuY3Rpb24gc2ltcGxlTGluZWFyUmVncmVzc2lvbih2YWx1ZXMsIGR0KSB7XG4gIC8vIG1lYW5zXG4gIGxldCB4U3VtID0gMDtcbiAgbGV0IHlTdW0gPSAwO1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB4U3VtICs9IGkgKiBkdDtcbiAgICB5U3VtICs9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIGNvbnN0IHhNZWFuID0geFN1bSAvIGxlbmd0aDtcbiAgY29uc3QgeU1lYW4gPSB5U3VtIC8gbGVuZ3RoO1xuXG4gIGxldCBzdW1EaWZmWE1lYW5TcXVhcmVkID0gMDsgLy8gc3VtWyBwb3coKHggLSB4TWVhbiksIDIpIF1cbiAgbGV0IHN1bURpZmZZTWVhblNxdWFyZWQgPSAwOyAvLyBzdW1bIHBvdygoeSAtIHlNZWFuKSwgMikgXVxuICBsZXQgc3VtRGlmZlhZTWVhbiA9IDA7ICAgICAgIC8vIHN1bVsgKHggLSB4TWVhbikoeSAtIHlNZWFuKSBdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpZmZYTWVhbiA9IGR0ICogaSAtIHhNZWFuO1xuICAgIGNvbnN0IGRpZmZZTWVhbiA9IHZhbHVlc1tpXSAtIHlNZWFuO1xuXG4gICAgY29uc3QgZGlmZlhNZWFuU3F1YXJlZCA9IGRpZmZYTWVhbiAqIGRpZmZYTWVhbjtcbiAgICBjb25zdCBkaWZmWU1lYW5TcXVhcmVkID0gZGlmZllNZWFuICogZGlmZllNZWFuO1xuICAgIGNvbnN0IGRpZmZYWU1lYW4gPSBkaWZmWE1lYW4gKiBkaWZmWU1lYW47XG5cbiAgICBzdW1EaWZmWE1lYW5TcXVhcmVkICs9IGRpZmZYTWVhblNxdWFyZWQ7XG4gICAgc3VtRGlmZllNZWFuU3F1YXJlZCArPSBkaWZmWU1lYW5TcXVhcmVkO1xuICAgIHN1bURpZmZYWU1lYW4gKz0gZGlmZlhZTWVhbjtcbiAgfVxuXG4gIC8vIGhvcml6b250YWwgbGluZSwgYWxsIHkgb24gc2FtZSBsaW5lXG4gIGlmIChzdW1EaWZmWU1lYW5TcXVhcmVkID09PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIFBlYXJzb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQ6XG4gIC8vIGNmLiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTJTQ2c4S3VoMHRFXG4gIC8vXG4gIC8vICAgICAgICAgICAgICAgICDiiJEgWyAoeCAtIHhNZWFuKSh5IC0geU1lYW4pIF1cbiAgLy8gciA9IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAgICAgc3FydCgg4oiRwqBbIHBvdygoeCAtIHhNZWFuKSwgMiksIHBvdygoeSAtIHlNZWFuKSwgMikgXSApXG4gIC8vXG4gIC8vXG4gIGNvbnN0IHIgPSBzdW1EaWZmWFlNZWFuIC8gTWF0aC5zcXJ0KHN1bURpZmZYTWVhblNxdWFyZWQgKiBzdW1EaWZmWU1lYW5TcXVhcmVkKTtcblxuICAvLyB0aGVuIHdlIGhhdmU6XG4gIC8vIGNmLiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUdocnhnYlFuRUVVXG4gIC8vXG4gIC8vIHkgPSBhICsgYnhcbiAgLy8gd2hlcmU6XG4gIC8vICAgICAgICAgU3lcbiAgLy8gYiA9IHIgKiAtLVxuICAvLyAgICAgICAgIFN4XG4gIC8vXG4gIC8vIGEgPSB5TWVhbiAtIGIgKiB4TWVhblxuICAvL1xuICAvLyBTIGZvciBzdGFuZGFyZCBkZXZpYXRpb25cbiAgLy8gICAgICAgICAgICDiiJEgWyBwb3coKHggLSB4TWVhbiksIDIpIF1cbiAgLy8gU3ggPSBzcXJ0KCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICApXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIE4gLSAxXG4gIGNvbnN0IFN4ID0gTWF0aC5zcXJ0KHN1bURpZmZYTWVhblNxdWFyZWQgLyAobGVuZ3RoIC0gMSkpO1xuICBjb25zdCBTeSA9IE1hdGguc3FydChzdW1EaWZmWU1lYW5TcXVhcmVkIC8gKGxlbmd0aCAtIDEpKTtcbiAgY29uc3QgYiA9IHIgKiAoU3kgLyBTeCk7XG5cbiAgcmV0dXJuIGI7XG59XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBzaXplOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIG1pbjogMixcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBkZWZhdWx0OiAzLFxuICB9LFxuICB1c2VGcmFtZVJhdGU6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gIH0sXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpbXBsZSBkZXJpdmF0aXZlIG9mIHN1Y2Nlc3NpdmUgdmFsdWUgdXNpbmdcbiAqIHNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbi5cbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFzc3VtZXMgYSBmaXhlZCBgZnJhbWVSYXRlYCAoYGZyYW1lLnRpbWVgIGlzIGlnbm9yZWQpXG4gKlxuICogQmVmb3JlIHRoZSBtb2R1bGUgaXMgZmlsbGVkLCBpdCBvdXRwdXRzIGEgdmFsdWUgb2YgMC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNpemU9M10gLSBTaXplIG9mIHRoZSB3aW5kb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy51c2VGcmFtZVJhdGU9bnVsbF0gLSBPdmVycmlkZSBzdHJlYW0gZnJhbWUgcmF0ZSBmb3JcbiAqICB0aGUgcmVncmVzc2lvblxuICovXG5jbGFzcyBEZWx0YSBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID3CoHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLnJpbmdJbmRleCA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSBudWxsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IGZyYW1lU2l6ZSAqIHNpemU7XG5cbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAvLyBjb3VudGVyIGJlZm9yZSB0aGUgb3BlcmF0b3Igc3RhcnRzIG91dHB1dGluZyBmcmFtZXNcbiAgICB0aGlzLnJpbmdJbmRleCA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSB0aGlzLnBhcmFtcy5nZXQoJ3VzZUZyYW1lUmF0ZScpID09PSBudWxsID9cbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZSA6XG4gICAgICB0aGlzLnBhcmFtcy5nZXQoJ3VzZUZyYW1lUmF0ZScpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyc1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlc2V0U3RyZWFtKCkge1xuICAgIHN1cGVyLnJlc2V0U3RyZWFtKCk7XG5cbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemU7IGorKylcbiAgICAgICAgYnVmZmVyc1tpXVtqXSA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc3VtZSBhIHN0cmVhbSBvZiB2ZWN0b3IgYXQgYSBmaXhlZCBgZnJhbWVSYXRlYC5cbiAgICovXG4gIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgLy8gY29uc3QgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgY29uc3QgZHQgPSAxIC8gdGhpcy5mcmFtZVJhdGU7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhkdCk7XG5cbiAgICBpZiAodGhpcy5yaW5nSW5kZXggPCBzaXplKVxuICAgICAgdGhpcy5yaW5nSW5kZXggKz0gMTtcblxuICAgIC8vIGNvcHkgaW5jb21taW5nIGRhdGEgaW50byBidWZmZXJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBpbmNvbW1pbmcgZnJhbWVzXG4gICAgICAvLyBzbyB3ZSBoYXZlIHRvIHNoaWZ0IGFsbCB0aGUgdmFsdWVzIGluIHRoZSBidWZmZXJzXG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHNpemU7IGorKylcbiAgICAgICAgYnVmZmVyW2ogLSAxXSA9IGJ1ZmZlcltqXTtcblxuICAgICAgYnVmZmVyW3NpemUgLSAxXSA9IGRhdGFbaV07XG5cbiAgICAgIGlmICh0aGlzLnJpbmdJbmRleCA+PSBzaXplKVxuICAgICAgICBvdXREYXRhW2ldID0gc2ltcGxlTGluZWFyUmVncmVzc2lvbihidWZmZXIsIGR0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0RGF0YVtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dERhdGE7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gICAgLy8gY2VudGVyIHRpbWUgYWNjb3JkaW5nIHRvIGRlbHRhIHNpemVcbiAgICBjb25zdCBzaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgY29uc3QgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgIHRoaXMuZnJhbWUudGltZSAtPSAwLjUgKiAoc2l6ZSAtIDEpIC8gZnJhbWVSYXRlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbHRhO1xuXG5cblxuXG5cbiJdfQ==