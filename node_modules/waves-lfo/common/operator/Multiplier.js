'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  // float or array
  factor: {
    type: 'any',
    default: 1
  }
};

/**
 * Multiply a given signal or vector by a given factor. On vector
 * streams, `factor` can be an array of values to apply on each dimension of the
 * vector frames.
 *
 * _support `standalone` usage_
 *
 * @param {Object} options - override default values
 * @param {Number|Array} [options.factor=1] - factor or array of factor to
 *  apply on the incomming frame. Setting an array is only defined in case of
 *  a vector stream.
 *
 * @memberof module:common.operator
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.operator.EventIn({
 *   type: 'vector',
 *   frameSize: 2,
 *   frameRate: 0,
 * });
 * const scaler = new lfo.operator.Multiplier({ factor: 0.1 });
 *
 * eventIn.connect(scaler);
 *
 * eventIn.process(null, [2, 3]);
 * > [0.2, 0.3]
 */

var Multiplier = function (_BaseLfo) {
  (0, _inherits3.default)(Multiplier, _BaseLfo);

  function Multiplier(options) {
    (0, _classCallCheck3.default)(this, Multiplier);
    return (0, _possibleConstructorReturn3.default)(this, (Multiplier.__proto__ || (0, _getPrototypeOf2.default)(Multiplier)).call(this, definitions, options));
  }

  /**
   * Use the `Multiplier` operator in standalone mode.
   *
   * @param {Float32Array|Array} data - Input vector
   * @return {Array} - Scaled values
   *
   * @example
   * const scaler = new Multiplier({ factor: [2, 4] });
   * scaler.initStream({ frameType: 'vector', frameSize: 2 });
   *
   * scaler.inputVector([3, 2]);
   * > [6, 8]
   */


  (0, _createClass3.default)(Multiplier, [{
    key: 'inputVector',
    value: function inputVector(data) {
      var output = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var factor = this.params.get('factor');

      if (Array.isArray(factor)) {
        for (var i = 0; i < frameSize; i++) {
          output[i] = data[i] * factor[i];
        }
      } else {
        for (var _i = 0; _i < frameSize; _i++) {
          output[_i] = data[_i] * factor;
        }
      }

      return output;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
    }

    /**
     * Use the `Multiplier` operator in standalone mode.
     *
     * @param {Float32Array|Array} data - Input signal.
     * @return {Array} - Scaled signal.
     *
     * @example
     * const scaler = new Multiplier({ factor: 0.1 });
     * scaler.initStream({ frameType: 'signal', frameSize: 2 });
     *
     * scaler.inputVector([1, 2]);
     * > [0.1, 0.2]
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var output = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var factor = this.params.get('factor');

      for (var i = 0; i < frameSize; i++) {
        output[i] = data[i] * factor;
      }return output;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.frame.data = this.inputSignal(frame.data);
    }
  }]);
  return Multiplier;
}(_BaseLfo3.default);

exports.default = Multiplier;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk11bHRpcGxpZXIuanMiXSwibmFtZXMiOlsiZGVmaW5pdGlvbnMiLCJmYWN0b3IiLCJ0eXBlIiwiZGVmYXVsdCIsIk11bHRpcGxpZXIiLCJvcHRpb25zIiwiZGF0YSIsIm91dHB1dCIsImZyYW1lIiwiZnJhbWVTaXplIiwic3RyZWFtUGFyYW1zIiwicGFyYW1zIiwiZ2V0IiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsImlucHV0VmVjdG9yIiwiaW5wdXRTaWduYWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztBQUVBLElBQU1BLGNBQWM7QUFDbEI7QUFDQUMsVUFBUTtBQUNOQyxVQUFNLEtBREE7QUFFTkMsYUFBUztBQUZIO0FBRlUsQ0FBcEI7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTZCTUMsVTs7O0FBQ0osc0JBQVlDLE9BQVosRUFBcUI7QUFBQTtBQUFBLHlJQUNiTCxXQURhLEVBQ0FLLE9BREE7QUFFcEI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWFZQyxJLEVBQU07QUFDaEIsVUFBTUMsU0FBUyxLQUFLQyxLQUFMLENBQVdGLElBQTFCO0FBQ0EsVUFBTUcsWUFBWSxLQUFLQyxZQUFMLENBQWtCRCxTQUFwQztBQUNBLFVBQU1SLFNBQVMsS0FBS1UsTUFBTCxDQUFZQyxHQUFaLENBQWdCLFFBQWhCLENBQWY7O0FBRUEsVUFBSUMsTUFBTUMsT0FBTixDQUFjYixNQUFkLENBQUosRUFBMkI7QUFDekIsYUFBSyxJQUFJYyxJQUFJLENBQWIsRUFBZ0JBLElBQUlOLFNBQXBCLEVBQStCTSxHQUEvQjtBQUNFUixpQkFBT1EsQ0FBUCxJQUFZVCxLQUFLUyxDQUFMLElBQVVkLE9BQU9jLENBQVAsQ0FBdEI7QUFERjtBQUVELE9BSEQsTUFHTztBQUNMLGFBQUssSUFBSUEsS0FBSSxDQUFiLEVBQWdCQSxLQUFJTixTQUFwQixFQUErQk0sSUFBL0I7QUFDRVIsaUJBQU9RLEVBQVAsSUFBWVQsS0FBS1MsRUFBTCxJQUFVZCxNQUF0QjtBQURGO0FBRUQ7O0FBRUQsYUFBT00sTUFBUDtBQUNEOztBQUVEOzs7O2tDQUNjQyxLLEVBQU87QUFDbkIsV0FBS0EsS0FBTCxDQUFXRixJQUFYLEdBQWtCLEtBQUtVLFdBQUwsQ0FBaUJSLE1BQU1GLElBQXZCLENBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBYVlBLEksRUFBTTtBQUNoQixVQUFNQyxTQUFTLEtBQUtDLEtBQUwsQ0FBV0YsSUFBMUI7QUFDQSxVQUFNRyxZQUFZLEtBQUtDLFlBQUwsQ0FBa0JELFNBQXBDO0FBQ0EsVUFBTVIsU0FBUyxLQUFLVSxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsUUFBaEIsQ0FBZjs7QUFFQSxXQUFLLElBQUlHLElBQUksQ0FBYixFQUFnQkEsSUFBSU4sU0FBcEIsRUFBK0JNLEdBQS9CO0FBQ0VSLGVBQU9RLENBQVAsSUFBWVQsS0FBS1MsQ0FBTCxJQUFVZCxNQUF0QjtBQURGLE9BR0EsT0FBT00sTUFBUDtBQUNEOztBQUVEOzs7O2tDQUNjQyxLLEVBQU87QUFDbkIsV0FBS0EsS0FBTCxDQUFXRixJQUFYLEdBQWtCLEtBQUtXLFdBQUwsQ0FBaUJULE1BQU1GLElBQXZCLENBQWxCO0FBQ0Q7Ozs7O2tCQUdZRixVIiwiZmlsZSI6Ik11bHRpcGxpZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgLy8gZmxvYXQgb3IgYXJyYXlcbiAgZmFjdG9yOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogMSxcbiAgfVxufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIGdpdmVuIHNpZ25hbCBvciB2ZWN0b3IgYnkgYSBnaXZlbiBmYWN0b3IuIE9uIHZlY3RvclxuICogc3RyZWFtcywgYGZhY3RvcmAgY2FuIGJlIGFuIGFycmF5IG9mIHZhbHVlcyB0byBhcHBseSBvbiBlYWNoIGRpbWVuc2lvbiBvZiB0aGVcbiAqIHZlY3RvciBmcmFtZXMuXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSBbb3B0aW9ucy5mYWN0b3I9MV0gLSBmYWN0b3Igb3IgYXJyYXkgb2YgZmFjdG9yIHRvXG4gKiAgYXBwbHkgb24gdGhlIGluY29tbWluZyBmcmFtZS4gU2V0dGluZyBhbiBhcnJheSBpcyBvbmx5IGRlZmluZWQgaW4gY2FzZSBvZlxuICogIGEgdmVjdG9yIHN0cmVhbS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8ub3BlcmF0b3IuRXZlbnRJbih7XG4gKiAgIHR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDIsXG4gKiAgIGZyYW1lUmF0ZTogMCxcbiAqIH0pO1xuICogY29uc3Qgc2NhbGVyID0gbmV3IGxmby5vcGVyYXRvci5NdWx0aXBsaWVyKHsgZmFjdG9yOiAwLjEgfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KHNjYWxlcik7XG4gKlxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsyLCAzXSk7XG4gKiA+IFswLjIsIDAuM11cbiAqL1xuY2xhc3MgTXVsdGlwbGllciBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgYE11bHRpcGxpZXJgIG9wZXJhdG9yIGluIHN0YW5kYWxvbmUgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXl9IGRhdGEgLSBJbnB1dCB2ZWN0b3JcbiAgICogQHJldHVybiB7QXJyYXl9IC0gU2NhbGVkIHZhbHVlc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBzY2FsZXIgPSBuZXcgTXVsdGlwbGllcih7IGZhY3RvcjogWzIsIDRdIH0pO1xuICAgKiBzY2FsZXIuaW5pdFN0cmVhbSh7IGZyYW1lVHlwZTogJ3ZlY3RvcicsIGZyYW1lU2l6ZTogMiB9KTtcbiAgICpcbiAgICogc2NhbGVyLmlucHV0VmVjdG9yKFszLCAyXSk7XG4gICAqID4gWzYsIDhdXG4gICAqL1xuICBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZhY3RvcicpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFjdG9yKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgICAgb3V0cHV0W2ldID0gZGF0YVtpXSAqIGZhY3RvcltpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgICAgb3V0cHV0W2ldID0gZGF0YVtpXSAqIGZhY3RvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgYE11bHRpcGxpZXJgIG9wZXJhdG9yIGluIHN0YW5kYWxvbmUgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXl9IGRhdGEgLSBJbnB1dCBzaWduYWwuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFNjYWxlZCBzaWduYWwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHNjYWxlciA9IG5ldyBNdWx0aXBsaWVyKHsgZmFjdG9yOiAwLjEgfSk7XG4gICAqIHNjYWxlci5pbml0U3RyZWFtKHsgZnJhbWVUeXBlOiAnc2lnbmFsJywgZnJhbWVTaXplOiAyIH0pO1xuICAgKlxuICAgKiBzY2FsZXIuaW5wdXRWZWN0b3IoWzEsIDJdKTtcbiAgICogPiBbMC4xLCAwLjJdXG4gICAqL1xuICBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZhY3RvcicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgIG91dHB1dFtpXSA9IGRhdGFbaV0gKiBmYWN0b3I7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpcGxpZXI7XG4iXX0=