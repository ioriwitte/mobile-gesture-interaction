'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo = require('../../core/BaseLfo');

var _BaseLfo2 = _interopRequireDefault(_BaseLfo);

var _SourceMixin2 = require('../../core/SourceMixin');

var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);

var _ticker = require('@ircam/ticker');

var _ticker2 = _interopRequireDefault(_ticker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  source: {
    type: 'any',
    default: null,
    metas: {
      kind: 'static'
    }
  }

  /**
   * Regenerate a vector stream (possibly in time) in time from a recording.
   * The given recording should comply with the format output by the DataRecorder
   * lfo.
   *
   *
   * @param {Object} options - Override parameters' default values.
   * @param {Array<Object>} [options.source] - Actual recording to process. Should
   *  be compliant with format output by the DataRecorder
   *
   * @see {@link module:common.sink.DataRecorder}
   */
};
var DataReader = function (_SourceMixin) {
  (0, _inherits3.default)(DataReader, _SourceMixin);

  function DataReader(options) {
    (0, _classCallCheck3.default)(this, DataReader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (DataReader.__proto__ || (0, _getPrototypeOf2.default)(DataReader)).call(this, definitions, options));

    _this.sourceStartTime = null;
    _this.sourceEndTime = null;

    _this._ticker = null;
    _this._frames = null;
    _this._frameIndex = 0;
    _this._numFrames = null;
    _this._hasStarted = false;

    /**
     * define if the recording has the format:
     * { time: [...], data: [[...], [...]] } // true
     * or
     * [{ time, data }, { time, data }]
     */
    _this._separateArrayFrames = null;

    _this.processFrame = _this.processFrame.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(DataReader, [{
    key: 'processStreamParams',
    value: function processStreamParams() {
      var source = this.params.get('source');

      try {
        source = JSON.parse();
      } catch (err) {} // already JSON, do nothing

      if (source === null) throw new Error('Undefined DataReader source');

      this.streamParams = source.streamParams;
      this._frames = source.frames;

      if (this.streamParams === undefined || this._frames === undefined) throw new Error('Invalid DataReader source');

      var frameRate = this.streamParams.frameRate;
      var frames = this._frames;
      var numFrames = this._separateArrayFrames ? frames.time.length : frames.length;
      var separateArrayFrames = Array.isArray(frames[0].time) ? true : false;

      if (frameRate === 0) {
        // the recording doesn't have a frameRate, estimate from 10 first frames
        var max = Math.min(10, numFrames);
        var sum = 0;

        for (var i = 0; i < max - 1; i++) {
          var time0 = separateArrayFrames ? frames.time[i] : frames[i].time;
          var time1 = separateArrayFrames ? frames.time[i + 1] : frames[i + 1].time;
          var dt = time1 - time0;
          sum += dt;
        }

        var _period = sum / (max - 1);
        this.streamParams.frameRate = 1 / _period;
      }

      this.sourceStartTime = separateArrayFrames ? frames.time[0] : frames[0].time;
      this.sourceEndTime = separateArrayFrames ? frames.time[numFrames - 1] : frames[numFrames - 1].time;
      this._numFrames = numFrames;
      this._separateArrayFrames = separateArrayFrames;

      var period = 1 / this.streamParams.frameRate;

      // keep only one ticker instance
      if (this._ticker === null) this._ticker = new _ticker2.default(period * 1000, this.processFrame);else this._ticker.period = period * 1000;

      this.propagateStreamParams();
    }

    /**
     * Start output stream.
     */

  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      if (this.initialized === false) {
        if (this.initPromise === null) // init has not yet been called
          this.initPromise = this.init();

        return this.initPromise.then(function () {
          return _this2.start();
        });
      }

      this._hasStarted = true;
      this._ticker.start();
    }

    /**
     * Stop the output stream and the pointer.
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this._hasStarted === true) {
        this._ticker.stop();
        // const end time
        var period = 1 / this.streamParams.frameRate;
        var offset = this.sourceStartTime;
        var endTime = this._frameIndex * period + offset;

        this._frameIndex = 0;
        this._hasStarted = false;

        this.finalizeStream(endTime);
      }
    }

    /**
     * Stop the output stream without reseting the pointer.
     */

  }, {
    key: 'pause',
    value: function pause() {
      if (this._hasStarted === true) {
        this._ticker.stop();

        this._hasStarted = false;
      }
    }

    /**
     * Go to a given time. The given time must be in the boundaries defined by the
     *
     *
     */

  }, {
    key: 'seek',
    value: function seek(time) {
      // find the index closest to the given time
      var duration = this.sourceEndTime - this.sourceStartTime;
      var offset = this.sourceStartTime;
      var phase = (time - offset) / (duration - offset);
      var index = Math.floor(phase * this._numFrames);

      this._frameIndex = index;
    }
  }, {
    key: 'prepareFrame',
    value: function prepareFrame() {
      // this prevent seek before start...
      // if (this._reinit === true) // source has been updated
      //   this._frameIndex = 0;

      (0, _get3.default)(DataReader.prototype.__proto__ || (0, _getPrototypeOf2.default)(DataReader.prototype), 'prepareFrame', this).call(this);
    }

    /**
     * Ticker callback
     * @private
     */

  }, {
    key: 'processFrame',
    value: function processFrame(logicalTime) {
      this.prepareFrame();

      var frame = void 0;

      if (this._separateArrayFrames) {
        var time = this._frames.time[this._frameIndex];
        var data = this._frames.data[this._frameIndex];

        frame = { time: time, data: data };
      } else {
        frame = this._frames[this._frameIndex];
      }

      this._frameIndex += 1;
      this.frame = frame;

      this.propagateFrame();

      if (this._frameIndex >= this._numFrames) this.stop();
    }
  }]);
  return DataReader;
}((0, _SourceMixin3.default)(_BaseLfo2.default));

exports.default = DataReader;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkRhdGFSZWFkZXIuanMiXSwibmFtZXMiOlsiZGVmaW5pdGlvbnMiLCJzb3VyY2UiLCJ0eXBlIiwiZGVmYXVsdCIsIm1ldGFzIiwia2luZCIsIkRhdGFSZWFkZXIiLCJvcHRpb25zIiwic291cmNlU3RhcnRUaW1lIiwic291cmNlRW5kVGltZSIsIl90aWNrZXIiLCJfZnJhbWVzIiwiX2ZyYW1lSW5kZXgiLCJfbnVtRnJhbWVzIiwiX2hhc1N0YXJ0ZWQiLCJfc2VwYXJhdGVBcnJheUZyYW1lcyIsInByb2Nlc3NGcmFtZSIsImJpbmQiLCJwYXJhbXMiLCJnZXQiLCJKU09OIiwicGFyc2UiLCJlcnIiLCJFcnJvciIsInN0cmVhbVBhcmFtcyIsImZyYW1lcyIsInVuZGVmaW5lZCIsImZyYW1lUmF0ZSIsIm51bUZyYW1lcyIsInRpbWUiLCJsZW5ndGgiLCJzZXBhcmF0ZUFycmF5RnJhbWVzIiwiQXJyYXkiLCJpc0FycmF5IiwibWF4IiwiTWF0aCIsIm1pbiIsInN1bSIsImkiLCJ0aW1lMCIsInRpbWUxIiwiZHQiLCJwZXJpb2QiLCJwcm9wYWdhdGVTdHJlYW1QYXJhbXMiLCJpbml0aWFsaXplZCIsImluaXRQcm9taXNlIiwiaW5pdCIsInRoZW4iLCJzdGFydCIsInN0b3AiLCJvZmZzZXQiLCJlbmRUaW1lIiwiZmluYWxpemVTdHJlYW0iLCJkdXJhdGlvbiIsInBoYXNlIiwiaW5kZXgiLCJmbG9vciIsImxvZ2ljYWxUaW1lIiwicHJlcGFyZUZyYW1lIiwiZnJhbWUiLCJkYXRhIiwicHJvcGFnYXRlRnJhbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsY0FBYztBQUNsQkMsVUFBUTtBQUNOQyxVQUFNLEtBREE7QUFFTkMsYUFBUyxJQUZIO0FBR05DLFdBQU87QUFDTEMsWUFBTTtBQUREO0FBSEQ7O0FBU1Y7Ozs7Ozs7Ozs7OztBQVZvQixDQUFwQjtJQXNCTUMsVTs7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O0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3lCQUtLZSxJLEVBQU07QUFDVDtBQUNBLFVBQU13QixXQUFXLEtBQUs1QyxhQUFMLEdBQXFCLEtBQUtELGVBQTNDO0FBQ0EsVUFBTTBDLFNBQVMsS0FBSzFDLGVBQXBCO0FBQ0EsVUFBTThDLFFBQVEsQ0FBQ3pCLE9BQU9xQixNQUFSLEtBQW1CRyxXQUFXSCxNQUE5QixDQUFkO0FBQ0EsVUFBTUssUUFBUXBCLEtBQUtxQixLQUFMLENBQVdGLFFBQVEsS0FBS3pDLFVBQXhCLENBQWQ7O0FBRUEsV0FBS0QsV0FBTCxHQUFtQjJDLEtBQW5CO0FBQ0Q7OzttQ0FFYztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7O2lDQUlhRSxXLEVBQWE7QUFDeEIsV0FBS0MsWUFBTDs7QUFFQSxVQUFJQyxjQUFKOztBQUVBLFVBQUksS0FBSzVDLG9CQUFULEVBQStCO0FBQzdCLFlBQU1jLE9BQU8sS0FBS2xCLE9BQUwsQ0FBYWtCLElBQWIsQ0FBa0IsS0FBS2pCLFdBQXZCLENBQWI7QUFDQSxZQUFNZ0QsT0FBTyxLQUFLakQsT0FBTCxDQUFhaUQsSUFBYixDQUFrQixLQUFLaEQsV0FBdkIsQ0FBYjs7QUFFQStDLGdCQUFRLEVBQUU5QixVQUFGLEVBQVErQixVQUFSLEVBQVI7QUFDRCxPQUxELE1BS087QUFDTEQsZ0JBQVEsS0FBS2hELE9BQUwsQ0FBYSxLQUFLQyxXQUFsQixDQUFSO0FBQ0Q7O0FBRUQsV0FBS0EsV0FBTCxJQUFvQixDQUFwQjtBQUNBLFdBQUsrQyxLQUFMLEdBQWFBLEtBQWI7O0FBRUEsV0FBS0UsY0FBTDs7QUFFQSxVQUFJLEtBQUtqRCxXQUFMLElBQW9CLEtBQUtDLFVBQTdCLEVBQ0UsS0FBS29DLElBQUw7QUFDSDs7O0VBektzQiw2Qzs7a0JBNEtWM0MsVSIsImZpbGUiOiJEYXRhUmVhZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcbmltcG9ydCBTb3VyY2VNaXhpbiBmcm9tICcuLi8uLi9jb3JlL1NvdXJjZU1peGluJztcbmltcG9ydCBUaWNrZXIgZnJvbSAnQGlyY2FtL3RpY2tlcic7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBzb3VyY2U6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnc3RhdGljJyxcbiAgICB9LFxuICB9LFxufVxuXG4vKipcbiAqIFJlZ2VuZXJhdGUgYSB2ZWN0b3Igc3RyZWFtIChwb3NzaWJseSBpbiB0aW1lKSBpbiB0aW1lIGZyb20gYSByZWNvcmRpbmcuXG4gKiBUaGUgZ2l2ZW4gcmVjb3JkaW5nIHNob3VsZCBjb21wbHkgd2l0aCB0aGUgZm9ybWF0IG91dHB1dCBieSB0aGUgRGF0YVJlY29yZGVyXG4gKiBsZm8uXG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgcGFyYW1ldGVycycgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLnNvdXJjZV0gLSBBY3R1YWwgcmVjb3JkaW5nIHRvIHByb2Nlc3MuIFNob3VsZFxuICogIGJlIGNvbXBsaWFudCB3aXRoIGZvcm1hdCBvdXRwdXQgYnkgdGhlIERhdGFSZWNvcmRlclxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb21tb24uc2luay5EYXRhUmVjb3JkZXJ9XG4gKi9cbmNsYXNzIERhdGFSZWFkZXIgZXh0ZW5kcyBTb3VyY2VNaXhpbihCYXNlTGZvKSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvdXJjZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VFbmRUaW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3RpY2tlciA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVzID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLl9udW1GcmFtZXMgPSBudWxsO1xuICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIGRlZmluZSBpZiB0aGUgcmVjb3JkaW5nIGhhcyB0aGUgZm9ybWF0OlxuICAgICAqIHsgdGltZTogWy4uLl0sIGRhdGE6IFtbLi4uXSwgWy4uLl1dIH0gLy8gdHJ1ZVxuICAgICAqIG9yXG4gICAgICogW3sgdGltZSwgZGF0YSB9LCB7IHRpbWUsIGRhdGEgfV1cbiAgICAgKi9cbiAgICB0aGlzLl9zZXBhcmF0ZUFycmF5RnJhbWVzID0gbnVsbDtcblxuICAgIHRoaXMucHJvY2Vzc0ZyYW1lID0gdGhpcy5wcm9jZXNzRnJhbWUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMoKSB7XG4gICAgbGV0IHNvdXJjZSA9IHRoaXMucGFyYW1zLmdldCgnc291cmNlJyk7XG5cbiAgICB0cnkge1xuICAgICAgc291cmNlID0gSlNPTi5wYXJzZSgpO1xuICAgIH0gY2F0Y2goZXJyKSB7fSAvLyBhbHJlYWR5IEpTT04sIGRvIG5vdGhpbmdcblxuICAgIGlmIChzb3VyY2UgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZGVmaW5lZCBEYXRhUmVhZGVyIHNvdXJjZScpO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMgPSBzb3VyY2Uuc3RyZWFtUGFyYW1zO1xuICAgIHRoaXMuX2ZyYW1lcyA9IHNvdXJjZS5mcmFtZXM7XG5cbiAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMgPT09IHVuZGVmaW5lZCB8fMKgdGhpcy5fZnJhbWVzID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRGF0YVJlYWRlciBzb3VyY2UnKTtcblxuICAgIGNvbnN0IGZyYW1lUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICBjb25zdCBmcmFtZXMgPSB0aGlzLl9mcmFtZXM7XG4gICAgY29uc3QgbnVtRnJhbWVzID0gdGhpcy5fc2VwYXJhdGVBcnJheUZyYW1lcyA/IGZyYW1lcy50aW1lLmxlbmd0aCA6IGZyYW1lcy5sZW5ndGg7XG4gICAgY29uc3Qgc2VwYXJhdGVBcnJheUZyYW1lcyA9IEFycmF5LmlzQXJyYXkoZnJhbWVzWzBdLnRpbWUpID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKGZyYW1lUmF0ZSA9PT0gMCkge1xuICAgICAgLy8gdGhlIHJlY29yZGluZyBkb2Vzbid0IGhhdmUgYSBmcmFtZVJhdGUsIGVzdGltYXRlIGZyb20gMTAgZmlyc3QgZnJhbWVzXG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbigxMCwgbnVtRnJhbWVzKTtcbiAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCB0aW1lMCA9IHNlcGFyYXRlQXJyYXlGcmFtZXMgPyBmcmFtZXMudGltZVtpXSA6IGZyYW1lc1tpXS50aW1lO1xuICAgICAgICBjb25zdCB0aW1lMSA9IHNlcGFyYXRlQXJyYXlGcmFtZXMgPyBmcmFtZXMudGltZVtpICsgMV0gOiBmcmFtZXNbaSArIDFdLnRpbWU7XG4gICAgICAgIGNvbnN0IGR0ID0gdGltZTEgLSB0aW1lMDtcbiAgICAgICAgc3VtICs9IGR0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwZXJpb2QgPSBzdW0gLyAobWF4IC0gMSk7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSAxIC8gcGVyaW9kO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlU3RhcnRUaW1lID0gc2VwYXJhdGVBcnJheUZyYW1lcyA/IGZyYW1lcy50aW1lWzBdIDogZnJhbWVzWzBdLnRpbWU7XG4gICAgdGhpcy5zb3VyY2VFbmRUaW1lID0gc2VwYXJhdGVBcnJheUZyYW1lcyA/IGZyYW1lcy50aW1lW251bUZyYW1lcyAtIDFdIDogZnJhbWVzW251bUZyYW1lcyAtIDFdLnRpbWU7XG4gICAgdGhpcy5fbnVtRnJhbWVzID0gbnVtRnJhbWVzO1xuICAgIHRoaXMuX3NlcGFyYXRlQXJyYXlGcmFtZXMgPSBzZXBhcmF0ZUFycmF5RnJhbWVzO1xuXG4gICAgY29uc3QgcGVyaW9kID0gMSAvIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcblxuICAgIC8vIGtlZXAgb25seSBvbmUgdGlja2VyIGluc3RhbmNlXG4gICAgaWYgKHRoaXMuX3RpY2tlciA9PT0gbnVsbClcbiAgICAgIHRoaXMuX3RpY2tlciA9IG5ldyBUaWNrZXIocGVyaW9kICogMTAwMCwgdGhpcy5wcm9jZXNzRnJhbWUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX3RpY2tlci5wZXJpb2QgPSBwZXJpb2QgKiAxMDAwO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBvdXRwdXQgc3RyZWFtLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAodGhpcy5pbml0UHJvbWlzZSA9PT0gbnVsbCkgLy8gaW5pdCBoYXMgbm90IHlldCBiZWVuIGNhbGxlZFxuICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG5cbiAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5zdGFydCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYXNTdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aWNrZXIuc3RhcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgcG9pbnRlci5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2hhc1N0YXJ0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gICAgICAvLyBjb25zdCBlbmQgdGltZVxuICAgICAgY29uc3QgcGVyaW9kID0gMSAvIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuc291cmNlU3RhcnRUaW1lO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHRoaXMuX2ZyYW1lSW5kZXggKiBwZXJpb2QgKyBvZmZzZXQ7XG5cbiAgICAgIHRoaXMuX2ZyYW1lSW5kZXggPSAwO1xuICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmZpbmFsaXplU3RyZWFtKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBvdXRwdXQgc3RyZWFtIHdpdGhvdXQgcmVzZXRpbmcgdGhlIHBvaW50ZXIuXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5faGFzU3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcblxuICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byBhIGdpdmVuIHRpbWUuIFRoZSBnaXZlbiB0aW1lIG11c3QgYmUgaW4gdGhlIGJvdW5kYXJpZXMgZGVmaW5lZCBieSB0aGVcbiAgICpcbiAgICpcbiAgICovXG4gIHNlZWsodGltZSkge1xuICAgIC8vIGZpbmQgdGhlIGluZGV4IGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHRpbWVcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuc291cmNlRW5kVGltZSAtIHRoaXMuc291cmNlU3RhcnRUaW1lO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuc291cmNlU3RhcnRUaW1lO1xuICAgIGNvbnN0IHBoYXNlID0gKHRpbWUgLSBvZmZzZXQpIC8gKGR1cmF0aW9uIC0gb2Zmc2V0KTtcbiAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IocGhhc2UgKiB0aGlzLl9udW1GcmFtZXMpO1xuXG4gICAgdGhpcy5fZnJhbWVJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgcHJlcGFyZUZyYW1lKCkge1xuICAgIC8vIHRoaXMgcHJldmVudCBzZWVrIGJlZm9yZSBzdGFydC4uLlxuICAgIC8vIGlmICh0aGlzLl9yZWluaXQgPT09IHRydWUpIC8vIHNvdXJjZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgLy8gICB0aGlzLl9mcmFtZUluZGV4ID0gMDtcblxuICAgIHN1cGVyLnByZXBhcmVGcmFtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRpY2tlciBjYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvY2Vzc0ZyYW1lKGxvZ2ljYWxUaW1lKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcblxuICAgIGxldCBmcmFtZTtcblxuICAgIGlmICh0aGlzLl9zZXBhcmF0ZUFycmF5RnJhbWVzKSB7XG4gICAgICBjb25zdCB0aW1lID0gdGhpcy5fZnJhbWVzLnRpbWVbdGhpcy5fZnJhbWVJbmRleF07XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fZnJhbWVzLmRhdGFbdGhpcy5fZnJhbWVJbmRleF07XG5cbiAgICAgIGZyYW1lID0geyB0aW1lLCBkYXRhIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lID0gdGhpcy5fZnJhbWVzW3RoaXMuX2ZyYW1lSW5kZXhdO1xuICAgIH1cblxuICAgIHRoaXMuX2ZyYW1lSW5kZXggKz0gMTtcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZUZyYW1lKCk7XG5cbiAgICBpZiAodGhpcy5fZnJhbWVJbmRleCA+PSB0aGlzLl9udW1GcmFtZXMpXG4gICAgICB0aGlzLnN0b3AoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhUmVhZGVyO1xuIl19