'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  filename: {
    type: 'string',
    default: null,
    constant: true
  },
  format: {
    type: 'enum',
    default: 'txt',
    list: ['txt', 'json', 'csv']
  }
  // header: {
  //   type: 'boolean',
  //   default: false,
  // },
};

/**
 * Record input frames into a file.
 *
 * @param {Object} options - Override default parameters.
 * @param {String} [options.filename=null] - Path of the output file.
 * @param {String} [options.format='txt'] - Format in which the data should
 *  be stored. Available options: 'txt', 'json' or 'csv'.
 *
 * @memberof module:node.sink
 *
 * @todo - add an option to store the `streamParams`
 *
 * @example
 * import path from 'path';
 * import EventIn from '../src/common/source/EventIn';
 * import Logger from '../src/common/sink/Logger';
 * import DataToFile from '../src/node/sink/DataToFile';
 *
 * const eventIn = new EventIn({
 *   frameSize: 2,
 *   frameRate: 1,
 *   frameType: 'vector',
 * });
 *
 * const dataToFile = new DataToFile({
 *   filename: path.join(__dirname, './node_sink.DataToFile.test.json'),
 *   format: 'json',
 * });
 *
 * const logger = new Logger({
 *   data: true,
 * });
 *
 * eventIn.connect(logger);
 * eventIn.connect(dataToFile);
 * eventIn.start();
 *
 * let time = 0;
 * const period = 1;
 *
 * (function loop(){
 *   const data = [Math.random(), Math.random()];
 *   eventIn.process(time, data);
 *
 *   time += period;
 *
 *   if (time < 20)
 *     setTimeout(loop, 300);
 *   else
 *     eventIn.stop();
 * }());
 */

var DataToFile = function (_BaseLfo) {
  (0, _inherits3.default)(DataToFile, _BaseLfo);

  function DataToFile() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, DataToFile);

    var _this = (0, _possibleConstructorReturn3.default)(this, (DataToFile.__proto__ || (0, _getPrototypeOf2.default)(DataToFile)).call(this, definitions, options));

    _this.firstRow = true;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(DataToFile, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var filename = this.params.get('filename');
      this.file = _fs2.default.createWriteStream(filename);

      var format = this.params.get('format');

      switch (format) {
        case 'txt':
          break;
        case 'json':
          this.file.write('[\n');
          break;
        case 'csv':
          var _streamParams = this.streamParams,
              description = _streamParams.description,
              frameSize = _streamParams.frameSize;


          var header = 'time';

          if (description !== null && description.length) {
            header += ',' + description.join(',');
          } else {
            for (var i = 0; i < frameSize; i++) {
              header += ',row-' + i;
            }
          }

          header += '\n';

          this.file.write(header);
          break;
      }
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      var format = this.params.get('format');

      switch (format) {
        case 'txt':
          break;
        case 'json':
          this.file.write('\n]');
          break;
        case 'csv':
          // this.file.write(endTime.toString());
          break;
      }
    }

    // process any kind of stream
    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal() {}
    /** @private */

  }, {
    key: 'processVector',
    value: function processVector() {}
    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar() {}

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      var format = this.params.get('format');
      var str = void 0;

      switch (format) {
        case 'txt':
          str = _util2.default.format('%s\n', frame.data);
          break;
        case 'json':
          frame.data = (0, _from2.default)(frame.data);
          str = (0, _stringify2.default)(frame);

          if (!this.firstRow) str = ',\n' + str;

          this.firstRow = false;
          break;
        case 'csv':
          str = frame.time + ',';
          str += _util2.default.format('%s\n', frame.data);
          break;
      }

      this.file.write(str);
    }
  }]);
  return DataToFile;
}(_BaseLfo3.default);

exports.default = DataToFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkRhdGFUb0ZpbGUuanMiXSwibmFtZXMiOlsiZGVmaW5pdGlvbnMiLCJmaWxlbmFtZSIsInR5cGUiLCJkZWZhdWx0IiwiY29uc3RhbnQiLCJmb3JtYXQiLCJsaXN0IiwiRGF0YVRvRmlsZSIsIm9wdGlvbnMiLCJmaXJzdFJvdyIsInByZXZTdHJlYW1QYXJhbXMiLCJwcmVwYXJlU3RyZWFtUGFyYW1zIiwicGFyYW1zIiwiZ2V0IiwiZmlsZSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwid3JpdGUiLCJzdHJlYW1QYXJhbXMiLCJkZXNjcmlwdGlvbiIsImZyYW1lU2l6ZSIsImhlYWRlciIsImxlbmd0aCIsImpvaW4iLCJpIiwiZW5kVGltZSIsImZyYW1lIiwic3RyIiwiZGF0YSIsInRpbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsY0FBYztBQUNsQkMsWUFBVTtBQUNSQyxVQUFNLFFBREU7QUFFUkMsYUFBUyxJQUZEO0FBR1JDLGNBQVU7QUFIRixHQURRO0FBTWxCQyxVQUFRO0FBQ05ILFVBQU0sTUFEQTtBQUVOQyxhQUFTLEtBRkg7QUFHTkcsVUFBTSxDQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLEtBQWhCO0FBSEE7QUFLUjtBQUNBO0FBQ0E7QUFDQTtBQWRrQixDQUFwQjs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0RNQyxVOzs7QUFDSix3QkFBMEI7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7QUFBQTs7QUFBQSw4SUFDbEJSLFdBRGtCLEVBQ0xRLE9BREs7O0FBR3hCLFVBQUtDLFFBQUwsR0FBZ0IsSUFBaEI7QUFId0I7QUFJekI7O0FBRUQ7Ozs7O3dDQUNvQkMsZ0IsRUFBa0I7QUFDcEMsV0FBS0MsbUJBQUwsQ0FBeUJELGdCQUF6Qjs7QUFFQSxVQUFNVCxXQUFXLEtBQUtXLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixVQUFoQixDQUFqQjtBQUNBLFdBQUtDLElBQUwsR0FBWSxhQUFHQyxpQkFBSCxDQUFxQmQsUUFBckIsQ0FBWjs7QUFFQSxVQUFNSSxTQUFTLEtBQUtPLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixRQUFoQixDQUFmOztBQUVBLGNBQVFSLE1BQVI7QUFDRSxhQUFLLEtBQUw7QUFDRTtBQUNGLGFBQUssTUFBTDtBQUNFLGVBQUtTLElBQUwsQ0FBVUUsS0FBVixDQUFnQixLQUFoQjtBQUNBO0FBQ0YsYUFBSyxLQUFMO0FBQUEsOEJBQ3FDLEtBQUtDLFlBRDFDO0FBQUEsY0FDVUMsV0FEVixpQkFDVUEsV0FEVjtBQUFBLGNBQ3VCQyxTQUR2QixpQkFDdUJBLFNBRHZCOzs7QUFHRSxjQUFJQyxTQUFTLE1BQWI7O0FBRUEsY0FBSUYsZ0JBQWdCLElBQWhCLElBQXdCQSxZQUFZRyxNQUF4QyxFQUFnRDtBQUM5Q0Qsc0JBQVUsTUFBTUYsWUFBWUksSUFBWixDQUFpQixHQUFqQixDQUFoQjtBQUNELFdBRkQsTUFFTztBQUNMLGlCQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosU0FBcEIsRUFBK0JJLEdBQS9CO0FBQ0VILHdCQUFVLFVBQVVHLENBQXBCO0FBREY7QUFFRDs7QUFFREgsb0JBQVUsSUFBVjs7QUFFQSxlQUFLTixJQUFMLENBQVVFLEtBQVYsQ0FBZ0JJLE1BQWhCO0FBQ0E7QUFyQko7QUF1QkQ7O0FBRUQ7Ozs7bUNBQ2VJLE8sRUFBUztBQUN0QixVQUFNbkIsU0FBUyxLQUFLTyxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsUUFBaEIsQ0FBZjs7QUFFQSxjQUFRUixNQUFSO0FBQ0UsYUFBSyxLQUFMO0FBQ0U7QUFDRixhQUFLLE1BQUw7QUFDRSxlQUFLUyxJQUFMLENBQVVFLEtBQVYsQ0FBZ0IsS0FBaEI7QUFDQTtBQUNGLGFBQUssS0FBTDtBQUNFO0FBQ0E7QUFSSjtBQVVEOztBQUVEO0FBQ0E7Ozs7b0NBQ2dCLENBQUU7QUFDbEI7Ozs7b0NBQ2dCLENBQUU7QUFDbEI7Ozs7b0NBQ2dCLENBQUU7O0FBRWxCOzs7O2lDQUNhUyxLLEVBQU87QUFDbEIsVUFBTXBCLFNBQVMsS0FBS08sTUFBTCxDQUFZQyxHQUFaLENBQWdCLFFBQWhCLENBQWY7QUFDQSxVQUFJYSxZQUFKOztBQUVBLGNBQVFyQixNQUFSO0FBQ0UsYUFBSyxLQUFMO0FBQ0VxQixnQkFBTSxlQUFLckIsTUFBTCxDQUFZLE1BQVosRUFBb0JvQixNQUFNRSxJQUExQixDQUFOO0FBQ0E7QUFDRixhQUFLLE1BQUw7QUFDRUYsZ0JBQU1FLElBQU4sR0FBYSxvQkFBV0YsTUFBTUUsSUFBakIsQ0FBYjtBQUNBRCxnQkFBTSx5QkFBZUQsS0FBZixDQUFOOztBQUVBLGNBQUksQ0FBQyxLQUFLaEIsUUFBVixFQUNFaUIsTUFBTSxRQUFRQSxHQUFkOztBQUVGLGVBQUtqQixRQUFMLEdBQWdCLEtBQWhCO0FBQ0E7QUFDRixhQUFLLEtBQUw7QUFDRWlCLGdCQUFNRCxNQUFNRyxJQUFOLEdBQWEsR0FBbkI7QUFDQUYsaUJBQU8sZUFBS3JCLE1BQUwsQ0FBWSxNQUFaLEVBQW9Cb0IsTUFBTUUsSUFBMUIsQ0FBUDtBQUNBO0FBaEJKOztBQW1CQSxXQUFLYixJQUFMLENBQVVFLEtBQVYsQ0FBZ0JVLEdBQWhCO0FBQ0Q7Ozs7O2tCQUdZbkIsVSIsImZpbGUiOiJEYXRhVG9GaWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcbmltcG9ydCBmc2UgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgZmlsZW5hbWU6IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlLFxuICB9LFxuICBmb3JtYXQ6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZGVmYXVsdDogJ3R4dCcsXG4gICAgbGlzdDogWyd0eHQnLCAnanNvbicsICdjc3YnXSxcbiAgfSxcbiAgLy8gaGVhZGVyOiB7XG4gIC8vICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAvLyAgIGRlZmF1bHQ6IGZhbHNlLFxuICAvLyB9LFxufTtcblxuXG4vKipcbiAqIFJlY29yZCBpbnB1dCBmcmFtZXMgaW50byBhIGZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZmlsZW5hbWU9bnVsbF0gLSBQYXRoIG9mIHRoZSBvdXRwdXQgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9J3R4dCddIC0gRm9ybWF0IGluIHdoaWNoIHRoZSBkYXRhIHNob3VsZFxuICogIGJlIHN0b3JlZC4gQXZhaWxhYmxlIG9wdGlvbnM6ICd0eHQnLCAnanNvbicgb3IgJ2NzdicuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpub2RlLnNpbmtcbiAqXG4gKiBAdG9kbyAtIGFkZCBhbiBvcHRpb24gdG8gc3RvcmUgdGhlIGBzdHJlYW1QYXJhbXNgXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuICogaW1wb3J0IEV2ZW50SW4gZnJvbSAnLi4vc3JjL2NvbW1vbi9zb3VyY2UvRXZlbnRJbic7XG4gKiBpbXBvcnQgTG9nZ2VyIGZyb20gJy4uL3NyYy9jb21tb24vc2luay9Mb2dnZXInO1xuICogaW1wb3J0IERhdGFUb0ZpbGUgZnJvbSAnLi4vc3JjL25vZGUvc2luay9EYXRhVG9GaWxlJztcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IEV2ZW50SW4oe1xuICogICBmcmFtZVNpemU6IDIsXG4gKiAgIGZyYW1lUmF0ZTogMSxcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGRhdGFUb0ZpbGUgPSBuZXcgRGF0YVRvRmlsZSh7XG4gKiAgIGZpbGVuYW1lOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9ub2RlX3NpbmsuRGF0YVRvRmlsZS50ZXN0Lmpzb24nKSxcbiAqICAgZm9ybWF0OiAnanNvbicsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHtcbiAqICAgZGF0YTogdHJ1ZSxcbiAqIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChsb2dnZXIpO1xuICogZXZlbnRJbi5jb25uZWN0KGRhdGFUb0ZpbGUpO1xuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIGxldCB0aW1lID0gMDtcbiAqIGNvbnN0IHBlcmlvZCA9IDE7XG4gKlxuICogKGZ1bmN0aW9uIGxvb3AoKXtcbiAqICAgY29uc3QgZGF0YSA9IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXTtcbiAqICAgZXZlbnRJbi5wcm9jZXNzKHRpbWUsIGRhdGEpO1xuICpcbiAqICAgdGltZSArPSBwZXJpb2Q7XG4gKlxuICogICBpZiAodGltZSA8IDIwKVxuICogICAgIHNldFRpbWVvdXQobG9vcCwgMzAwKTtcbiAqICAgZWxzZVxuICogICAgIGV2ZW50SW4uc3RvcCgpO1xuICogfSgpKTtcbiAqL1xuY2xhc3MgRGF0YVRvRmlsZSBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmZpcnN0Um93ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBmaWxlbmFtZSA9IHRoaXMucGFyYW1zLmdldCgnZmlsZW5hbWUnKTtcbiAgICB0aGlzLmZpbGUgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmaWxlbmFtZSk7XG5cbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnBhcmFtcy5nZXQoJ2Zvcm1hdCcpO1xuXG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgJ3R4dCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIHRoaXMuZmlsZS53cml0ZSgnW1xcbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nzdic6XG4gICAgICAgIGNvbnN0IHsgZGVzY3JpcHRpb24sIGZyYW1lU2l6ZcKgfSA9IHRoaXMuc3RyZWFtUGFyYW1zO1xuXG4gICAgICAgIGxldCBoZWFkZXIgPSAndGltZSc7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlciArPSAnLCcgKyBkZXNjcmlwdGlvbi5qb2luKCcsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgICAgICAgIGhlYWRlciArPSAnLHJvdy0nICsgaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlciArPSAnXFxuJztcblxuICAgICAgICB0aGlzLmZpbGUud3JpdGUoaGVhZGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnBhcmFtcy5nZXQoJ2Zvcm1hdCcpO1xuXG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgJ3R4dCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIHRoaXMuZmlsZS53cml0ZSgnXFxuXScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nzdic6XG4gICAgICAgIC8vIHRoaXMuZmlsZS53cml0ZShlbmRUaW1lLnRvU3RyaW5nKCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGFueSBraW5kIG9mIHN0cmVhbVxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbCgpIHt9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzVmVjdG9yKCkge31cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTY2FsYXIoKSB7fVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnBhcmFtcy5nZXQoJ2Zvcm1hdCcpO1xuICAgIGxldCBzdHI7XG5cbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSAndHh0JzpcbiAgICAgICAgc3RyID0gdXRpbC5mb3JtYXQoJyVzXFxuJywgZnJhbWUuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIGZyYW1lLmRhdGEgPSBBcnJheS5mcm9tKGZyYW1lLmRhdGEpO1xuICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShmcmFtZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0Um93KVxuICAgICAgICAgIHN0ciA9ICcsXFxuJyArIHN0cjtcblxuICAgICAgICB0aGlzLmZpcnN0Um93ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY3N2JzpcbiAgICAgICAgc3RyID0gZnJhbWUudGltZSArICcsJztcbiAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KCclc1xcbicsIGZyYW1lLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmZpbGUud3JpdGUoc3RyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhVG9GaWxlO1xuIl19